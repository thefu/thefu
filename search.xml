<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android中view的理解</title>
    <url>/2022/09/25/Android%E4%B8%ADview%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="View是什么？"><a href="#View是什么？" class="headerlink" title="View是什么？"></a>View是什么？</h3><p>View是屏幕上的一块矩形区域，它负责用来显示一个区域，并且响应这个区域内的事件。可以说，手机屏幕上的任意一部分看得见的地方都是view，它很常见，比如TextView、imageview、button、以及linearLayout、relativelayout都是继承于view的。<br>对于activity来说，我们通过setContentView添加的布局到activity上，实际上都是添加到了activity内部的decorview上面，这个DecorView，其实就是一个FrameLayout，因此实际上，我们的布局是添加到了FrameLayout里面。</p>
<h2 id="View绘制的三个流程"><a href="#View绘制的三个流程" class="headerlink" title="View绘制的三个流程"></a>View绘制的三个流程</h2><p>我们知道，在自定义view的时候一般需要重写父类的onMeasure()、onLayout()、onDraw()三个方法，来完成视图的展示过程。当然，这三个暴露给开发者重写的方法只不过是整个绘制流程的冰山一角，更多复杂的幕后工作，都让系统给代劳了，一个完整的绘制流程包括measure、layout、draw三个步骤，其中：<br>measure：测量。系统会现根据xml布局文件和代码中对控件属性的设置，来获取或者计算出每个view和viewgroup的尺寸，并将这些尺寸保存下来。<br>layout：布局。根据测量出的结果以及对应的参数，来确定每一个控件应该显示的位置。<br>draw：绘制。确定好位置后，就将这些控件绘制到屏幕上。</p>
<h2 id="Android视图层次结果简介"><a href="#Android视图层次结果简介" class="headerlink" title="Android视图层次结果简介"></a>Android视图层次结果简介</h2><p>在介绍view绘制流程之间，咱们先接单介绍一下Android视图层次结果以及DecorView因为view的绘制流程的入口和DecorView有着密切的联系。</p>
<p>咱们平时看到的视图，其实存在如上的嵌套关系。上图是针对比较老的Android系统版本中制作的，新的版本中会略有出入，还有一个状态栏，但整体上没变。我们平时在activity中setContentView(…)中对应layout内容，对应的是上图中viewgrop的树状结构，实际上添加到系统中时，会再裹上一层FrameLayout，就是上图中最里面的浅蓝色部分。<br>这里咱们再通过一个实例来继续查看。Androidstudio工具中提供了一个布局观察期工具，通过Tools &gt; android &gt; layout Inspector可以查看具体某个activity的布局情况。下图中，左边树状结果对应了右边的可视图，可见DecorView就是整个界面的根视图，对应右边的红色框，是整个屏幕的大小。黄色边框为状态栏部分；那个绿色边框中有两个部分，一个是白框中的actionBar，对应了上图中紫色部分的TitleActionBar部分，即标题栏，平时咱们可以在activity中将其隐藏掉；另外一个蓝色边框部分，对应上图中最里面的蓝色部分，即contentview部分，下图中左边有两个蓝色框，上面那个中有个布局”content_layout”，咱们能通过layout布局文件直接完全操作的也就是这一块，当其被add到视图系统中时，会被过上contentFramelayout（显然是FrameLayout的子类），这也就是为什么添加到layout.xml视图的方法叫setContentView()而不叫setView()的原因了。</p>
<h2 id="故事开始的地方"><a href="#故事开始的地方" class="headerlink" title="故事开始的地方"></a>故事开始的地方</h2><p>如果对activity的启动流程有一定的了解的话，应该知道这个启动会在activityThread.java类中完成，在启动activity的过程中，会调用handleResumeActivity()方法，关于视图的绘制过程最初就是从这个方法开始的。</p>
<h3 id="1-view绘制起源UML时序图"><a href="#1-view绘制起源UML时序图" class="headerlink" title="1.view绘制起源UML时序图"></a>1.view绘制起源UML时序图</h3><p>整个调用链如下图所示，知道ViewRootImpl类中的performTraversals()中，才正式开始绘制流程了，所以一般都是以该方法作为正式绘制的源头。</p>
<h3 id="2-handResumeActivity-方法"><a href="#2-handResumeActivity-方法" class="headerlink" title="2.handResumeActivity()方法"></a>2.handResumeActivity()方法</h3><p>在这先大致看一下ActivityThread类中的handleResumeActivity方法，咱们这里只贴出关键代码：<br><code>//===========ActivityThread.java========== final void handleResumeActivity(...) &#123;     ......     //跟踪代码后发现其初始赋值为mWindow = new PhoneWindow(this, window, activityConfigCallback);     r.window = r.activity.getWindow();        //从PhoneWindow实例中获取DecorView     View decor = r.window.getDecorView();     ......     //跟踪代码后发现，vm值为上述PhoneWindow实例中获取的WindowManager。     ViewManager wm = a.getWindowManager();     ......     //当前window的属性，从代码跟踪来看是PhoneWindow窗口的属性     WindowManager.LayoutParams l = r.window.getAttributes();     ......     wm.addView(decor, l);     ...... &#125;</code><br>上述代码第八行中，ViewManager是一个接口，addView是其中定义一个空方法，WindowManager是其子类，WindowManagerImpl是WindowManager的实现类，在第四行代码中的r.window的值可以根据Activity.java的如下代码得知，其值为PhoneWindow实例。<br>&#96;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Activity.java&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>private Window mWindow;<br>public Window getWindow() {<br>   return mWindow;<br>}</p>
<p>final void attach(…){<br>   ……<br>   mWindow &#x3D; new PhoneWindow(this, window, activityConfigCallback);<br>   ……<br>}&#96;</p>
<h3 id="3-两个重要参数分析"><a href="#3-两个重要参数分析" class="headerlink" title="3.两个重要参数分析"></a>3.两个重要参数分析</h3><p>之所以要在这里特意分析handleResumeActivity()方法，除了因为它是整个绘制流程的最初源头外，还有就是addView的两个参数比较重要，它们经过一层一层传递后进入到ViewRootImpl中，在后面分析绘制中要用到。这里再看看这两个参数的相关信息：<br>（1）参数dector<br>&#96;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Activity.java&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>private Window mWindow;<br>public Window getWindow() {<br>   return mWindow;<br>}</p>
<p>final void attach(…){<br>   ……<br>   mWindow &#x3D; new PhoneWindow(this, window, activityConfigCallback);<br>   ……<br>}<code>可见decor参数表示的是DecorView实例，注释中也有说明：这是window的顶级视图，包含了window的decor （2）参数l</code>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Window.java&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F;The current window attributes.<br>    private final WindowManager.LayoutParams mWindowAttributes &#x3D;<br>        new WindowManager.LayoutParams();<br>……<br>public final WindowManager.LayoutParams getAttributes() {<br>        return mWindowAttributes;<br>    }<br>……</p>
<p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WindowManager.java的内部类LayoutParams extends ViewGroup.LayoutParams&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>public LayoutParams() {<br>            super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);<br>            ……<br>        }</p>
<p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ViewGroup.java内部类LayoutParams&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>public LayoutParams(int width, int height) {<br>            this.width &#x3D; width;<br>            this.height &#x3D; height;<br>        }&#96;<br>该参数表示的是PhoneWindow的LayoutParams属性，其width和height值均为LayoutParmas.MATCH_PARENT。<br>在源码中，WindowPhone和DecorView通过组合方法联系在一起的，而DecorView是整个View体系的根View。在前面handleResumeActivity()方法代码片段中，当Activity启动后，就通过第14行的addView方法，来间接调用ViewRootImpl类中的performTraversals()，从而实现视图的绘制。</p>
]]></content>
  </entry>
  <entry>
    <title>如何解决hexo首页显示博客的全部文章</title>
    <url>/2022/09/25/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3hexo%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>在第一次书写博客后，应该会发现自己整篇博客的文章都在这个首页中显示，可能一个两个还好，但是越往后，自己写的博客越多，全都放在首页堆积，就会显得十分臃肿</p>
<span id="more"></span>

<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p><code>首页在主题的_config.yml中把设置打开：（安装时默认就打开了） excerpt_description: true</code></p>
<h3 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h3><p>在文章的front-matter中（即new一个博客时生成的内容里）添加description，其中description中的内容就会被显示到首页上，其余一律不显示。<br><code>title: 让首页显示部分内容 date: 2020-02-23 22:55:10 description: 这是显示在首页的概述，正文内容均会被隐藏。</code><br>比较不方便的是还需要写一个概述，很多时候懒得写概述，于是就需要第二种方法了。</p>
<h3 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h3><p>在需要截断的地方加入：<br><code>&lt;!--more--&gt;</code><br>首页就会显示这条以上的所有内容，隐藏接下来的内容。比如本文就是使用了这种方法<br>这个明显就方便许多，当然有利有弊，比如开头都是废话的首页开着就不是很爽，因此我一般会先选择方法二，如果感觉文章前面写的不好就用方法一。</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解进程和线程</title>
    <url>/2022/09/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>平时helloworld这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和IO设备。处理器看上去就像在不间断地一条接一条执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象，这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。<br>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中。需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是在多核系统中，一个CPU看上去都像是在并发执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。（为了简化，下面的讨论我们只考虑包含一个CPU的单处理器系统的情况）<br>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，及保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。下图展示了程序运行场景的基本理念。<br><img src="https://s3.bmp.ovh/imgs/2022/09/25/9a7e5808598c7948.jpg"><br>示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输入。当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程以及其上下文，然后将控制权传给新的hell咯进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它，shell进程会继续等待下一个命令行输入。<br>如上图所示，从一个进程到另一个进程的转换是由操作系统内核管理的，内核时操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。<br>实现进程这个抽象概念需要低级硬件和操作系统软件之间紧密合作。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快得方法。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在独占地使用主存。每个进程看到内存都是一致得，称为虚拟地址空间。下图所示是Linux进程的虚拟地址空间（其他Unix系统的设计也与此类似）。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据。请注意，途中的地址是从下往上增大的。<br><img src="https://s3.bmp.ovh/imgs/2022/09/25/39151a55fce31299.png"><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能，以下从最低的地址开始，逐步向上介绍：</p>
<h3 id="程序代码和数据"><a href="#程序代码和数据" class="headerlink" title="程序代码和数据"></a>程序代码和数据</h3><p>对所有的进程来说，代码是从同一固定地址开始，紧接着的是和PC全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello，</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被制定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</p>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>大约在地址空间中的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域，共享库的概念非常强大，</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用，和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</p>
<h3 id="内存虚拟内存"><a href="#内存虚拟内存" class="headerlink" title="内存虚拟内存"></a>内存虚拟内存</h3><p>地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用呢耦合代码定义的函数。相反，它们必须调用内核来执行这些操作</p>
<p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件编译。其基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后主存作为磁盘的高速缓存，</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是字节序列，仅此而已。每个IO设备，包括磁盘，键盘，显示器，甚至网络，都可以看成是文件，系统中所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统函数调用读写文件按来实现的<br>文件这个简单而精致的概念是非常强大的，因为它向应用程序中提供了一个统一的试图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无需了解具体的磁盘技术，进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。</p>
]]></content>
  </entry>
  <entry>
    <title>GitHub+Hexo搭建个人博客网站</title>
    <url>/2022/09/18/GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="什么是hexo？"><a href="#什么是hexo？" class="headerlink" title="什么是hexo？"></a>什么是hexo？</h2><p>Hexo是一款基于Node.js的静态博客框架，特点是快速，简介并且高效的博客框架，Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。它可以方便的生成静态网页托管在GitHub和其他托管平台上，是搭建博客的首选框架。</p>
<span id="more"></span>
<h2 id="什么是github？"><a href="#什么是github？" class="headerlink" title="什么是github？"></a>什么是github？</h2><p>GitHub是一个在线软件源代码托管服务平台，使用Git作为版本控制软件，是世界上最大的代码托管网站和开源社区。我们使用的是github上的一个服务，GitHub Pages，它是由GitHub提供的一个网页寄存服务，可以用于存放静态网页，包括博客，项目文档甚至整本书。一般GitHub Pages使用github.io的子域名，但是用户也可以使用第三方域名。</p>
<h2 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h2><h3 id="1-GitHub创建个人仓库"><a href="#1-GitHub创建个人仓库" class="headerlink" title="1.GitHub创建个人仓库"></a>1.GitHub创建个人仓库</h3><p>登录到GitHub，如果没有GitHub账号，使用你的邮箱注册GitHub账号，点击GitHub中的New repository创建新仓库，仓库名应该为：“用户名.github,io”这个用户名使用你的github账号名称代替，这是一个相对固定的写法。</p>
<h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><p>什么是git？简单来说Git是开源的分布式版本控制系统，用于敏捷高效的处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上，推荐一个巨好的<a href="http://git.oschina.net/progit/index.html">git教程</a>。<br>安装成功后，将你的Git与GitHub账号绑定，鼠标右击打开Git Bash，设置user.name和user.eamil配置信息：<br>git config –global user.name “你的GitHub用户名”<br>git config –global user.email “你的GitHub注册邮箱”<br>生成ssh密钥文件：<br>ssh-keygen -t rsa -C “你的GitHub注册邮箱”<br>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh文件夹中的id_rsa.pub密钥，将内容全部复制<br>打开GitHub_Settings_keys页面，新建new SSH Key<br>Title为标题，任意填写即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH Key。<br>在git bash中检测GitHub公钥是否成功，输入ssh <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a><br>这里之所以设置GitHub密钥的原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在github上，私钥放置在自己的电脑里。github要求每次推送代码都是合法用户，所以每次推送都要输入账号密码验证推送用户是否合法用户，为了省去每次输入密码的步骤，采用ssh，当你推送的时候，git就会匹配你的私钥跟github上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。</p>
<h3 id="3-安装Node-js"><a href="#3-安装Node-js" class="headerlink" title="3.安装Node.js"></a>3.安装Node.js</h3><p>Hexo基于Node.js，<a href="https://nodejs.org/en/download/">Node.js下载地址</a>，注意安装node.js会包含环境变量及npm的安装，安装后，检测node.js是否安装成功，在命令行输入node -v，检测npm是否安装成功，npm -v<br>到这儿，安装Hexo的环境已经全部搭建完成。</p>
<h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h3><p>hexo就是我们的个人博客网站的框架，这里需要自己在电脑里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中，创建好后，进入文件夹中，打开命令行窗口。<br>使用npm命令安装Hexo，输入：<br>npm install -g hexo-cli<br>这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：<br>hexo init blog<br>注意：这里的命令都是作用在刚刚创建的blog文件夹中。<br>在命令行中输入启动命令：<br>hexo server<br>打开浏览器哦网址可以看到网站的样式</p>
<h3 id="5-推送网站"><a href="#5-推送网站" class="headerlink" title="5.推送网站"></a>5.推送网站</h3><p>上面只是在本地预览，接下来要做的就是推送网站，也就是发布网站，让我们的网站可以被更多人访问到。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件<br>进入themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件<br>现在需要做的是将我们的Hexo和GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：<br>deploy:<br>type: git<br>repo: 这里填入你之前在GitHub上创建仓库的完整历经，记得加上.git<br>branch: master<br>保存站点配置文件。<br>其实就是给hexo d这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里，最后安装git部署插件，输入命令：<br>npm install hexo-deployer-git –save<br>这时，我们分别输入三条命令：<br>hexo clean<br>hexo g<br>hexo d<br>其实第三条hexo d就是部署网站的命令，d是deploy的缩写，完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，你就可以发现你的博客已经上线了，可以在网络上被访问到。</p>
<h2 id="常用hexo命令及解释"><a href="#常用hexo命令及解释" class="headerlink" title="常用hexo命令及解释"></a>常用hexo命令及解释</h2><p>hexo init [folder]<br>新建一个网站。如果没有设置folder，Hexo默认在目前的文件夹建立网站。<br>本命令相当于执行了以下几步：<br>1.Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a>和<a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a>主题到当前目录或者指定目录<br>2.使用<a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a>或者<a href="https://docs.npmjs.com/cli/install">npm</a>包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm默认随<a href="https://hexo.io/docs/#Install-Node-js">Node.js</a>安装。</p>
<p>hexo new [layout] &lt;title&gt;<br>新建一篇文章。如果没有设置layout的话，默认使用_config.yml中的default_layout参数代替，如果标题包含空格的话，请使用引号括起来。<br>默认情况下，Hexo会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo会创建一个以标题为名字的目录，并在目录中放置一个index.md文件。你可以使用–path参数覆盖上述行为、自行决定文件的目录：<br>hexo new page –path about&#x2F;me “About me”<br>以上命令会创建一个source&#x2F;about&#x2F;me.md，同时me.md的Front Matter中的title为“page”。这是因为在上述命令中，hexo-cli将page视为指定文章的标题，并采用默认的layout</p>
<p>hexo generate<br>生成静态文件。</p>
<p>hexo publish [layout] &lt;filename&gt;<br>发表草稿</p>
<p>hexo server<br>启动服务器，默认情况下，访问地址为：<br><a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
<p>hexo deploy<br>部署网站。</p>
<p>hexo clean<br>清楚缓存文件（db.json）和已生成的静态文件（public)。在某些情况下（尤其是更换主题后）,如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<p>hexo list &lt;type&gt;<br>列出网站资料</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>hexo –safe<br>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<p>hexo –debug<br>在终端中显示调试信息并记录到debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并<a href="https://github.com/hexojs/hexo/issues/new">提交调式信息到GitHub</a>.</p>
<p>hexo –silent<br>隐藏终端信息。</p>
<p>更多详情可以查看<a href="https://zhuanlan.zhihu.com/p/26625249">此篇文档</a></p>
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>APP性能优化的一些建议</title>
    <url>/2022/10/15/APP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>除了利用性能测试工具分析性能应用，寻找优化控件，开发者在开发过程中，就应该注意一些性能优化技巧，养成良好的开发习惯，减轻性能优化的负担。下面是一些优化建议：</p>
<span id="more"></span>
<p>1.在LinearLayout和RelativeLayout都可以完成布局的情况下优先选择LinearLayout，可以减少View的层级，但是注意相同组件可能RelativeLayout绘制时间长<br>2.onDraw中不要创建新的局部对象，onDraw方法中不要做耗时的任务<br>3.不要在主线程进行网络访问&#x2F;大文件的IO操作<br>4.绘制UI时，尽量减少绘制UI层次；减少不必要的view嵌套<br>5.当我们的布局是用的FrameLayout的时候，我们可以把它改成merge，可以避免自己的帧布局和系统的ContentFrameLayout帧布局重叠造成重复计算（measure和layout）<br>6.在view层级相同的情况下，尽量使用LinearLayout而不是RelativeLayout；因为RelativeLayout在测量的时候会测量两次，而LinearLayout测量一次<br>7.删除控件中无用的属性<br>8.布局复用，比如listview布局复用<br>9.尽量避免过度绘制（overdraw）比如：背景经常容易造成过度绘制，由于我们布局设置了背景，溶蚀用到MaterialDesign的主题会默认给一个背景。这时应该把主题添加的背景去掉；还有移除XML中非必须的背景<br>10.自定义view优化，使用canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。也是避免过度绘制。<br>11.启动优化，启动速度的监控，发现影响启动速度的问题所在，优化启动逻辑，提高应用的启动速度。比如闪屏页面，合理优化布局，加载逻辑优化，数据准备。<br>12.合理的刷新机制，尽量减少刷新次数，尽量避免后台有高的CPU线程运行，缩小刷新区域。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>EditText:android:focusable和android:focusableInTouchMode的区别</title>
    <url>/2022/10/15/EditText-android-focusable%E5%92%8Candroid-focusableInTouchMode%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>本文向大家介绍EditText:android:focusable和android:focusableInTouchMode的区别，主要包括EditText:android:focusable和android:focusableInTouchMode的区别使用实例，应用技巧，基本知识点总结和需要注意事项，具有一定的参考价值。<br>android:focusable</p>
<span id="more"></span>
<p>之所以有这个属性主要是因为android系统不仅仅是针对手机的，有可能在电视，手表等等的非触摸输入设备上（比如android TV）这些设备只有物理上下键不具备触摸功能，<br>那么当把这个属性值设置为true的时候，比如你按了一下向下键，屏幕上的内容就会对应选中一个向下的控件（如果这个控件设置android:focusable&#x3D;true的话），否则就会选中下一个具备focusable能力的控件。<br>android:focusableInTouchMode<br>与上面的那种情况相反，如果是针对手机开发的话，那么大部分手机都具备触摸功能，那么这个属性有什么作用呢？<br>从交互的角度来讲，焦点的作用其实就是为了提示用户当前控件已经被选中了，可以进行下一步的操作。比如在android5.0上新退出的Material Design效果上面，如果一个EditText被选中了，那么它的输入框就会更换颜色以示区别，但是在手机开发中并不是所有的控件都需要有选中的这种状态，通常在点击后可能只想达到某种效果（如点击按钮就是想触发点击事件，不需要有选中效果），那么这个时候，如果把android:focusableInTouchMode设置为true，此时执行的就是更换焦点操作，相应的事件就无法得到及时相应，这样的体验就会很不好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ddffff&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:focusableInTouchMode=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    </span><br><span class="line">    &lt;View</span><br><span class="line">        android:id=&quot;@+id/view_test&quot;</span><br><span class="line">        android:layout_width=&quot;100dip&quot;</span><br><span class="line">        android:layout_height=&quot;100dip&quot;</span><br><span class="line">        android:focusableInTouchMode=&quot;true&quot;</span><br><span class="line">        android:background=&quot;#ff0000&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/bt_test&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginBottom=&quot;20dp&quot;</span><br><span class="line">        android:text=&quot;click me&quot;</span><br><span class="line">        android:focusableInTouchMode=&quot;true&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>我们分别为LinearLayout，View，Button都增加一个触摸时能够获取到焦点的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.yuneec.testdemo;</span><br><span class="line">import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private View view_test;</span><br><span class="line">    private Button bt_test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        view_test = findViewById(R.id.view_test);</span><br><span class="line">        bt_test = (Button) findViewById(R.id.bt_test);</span><br><span class="line"></span><br><span class="line">        view_test.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;I am view, click................&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        view_test.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFocusChange(View v, boolean hasFocus) &#123;</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;==========================================&quot;);</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;I am view, focus: &quot;+view_test.isFocused());</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;I am button, focus: &quot;+bt_test.isFocused());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        bt_test.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;I am button, click................&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        bt_test.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFocusChange(View v, boolean hasFocus) &#123;</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;==========================================&quot;);</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;I am button, focus: &quot;+bt_test.isFocused());</span><br><span class="line">                Log.i(&quot;xp.chen&quot;, &quot;I am view, focus: &quot;+view_test.isFocused());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先点击View，发现View的onClick事件未打印，再点击view，发现view的onclick事件可以正常打印了。<br>然后点击button，发现button的onclick事件也未打印，再点击一次button，发现button的onclick事件可以正常打印了。<br>这说明第一次点击view或者button，知识单纯将焦点转换到了view和button上，此时会调用onFocusChangeListener方法，只有当再次点击的时候才会调用onClick方法。<br>因此，这种操作对Button来说是多余的，而button的android:focusableInTouchMode属性默认也就是false。<br>但对于EditText这种控件来说就不一样了，比方说一个界面上有很多EditText，在你点击了其中一个的时候，你必须先告知用户他点击的是哪一个，这样用户才不会输错，事实上在android源代码里面，EditText的focusableInTouchMode属性默认也就是True。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB(android调试桥)</title>
    <url>/2022/10/15/ADB-android%E8%B0%83%E8%AF%95%E6%A1%A5/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>android调试桥（adb）是一种功能多样的命令行工具，可让您与设备进行通信。adb命令可用于执行各种设备操作（例如安装和调试应用）,并提供对Unix shell（可用来在设备商运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：<br>客户端：用于发送命令。客户端在开发机器上运行。您可以通过发出adb命令从命令行终端调用客户端。<br>守护程序（adbd）：用于在设备商运行命令。守护程序在每个设备上作为后台进程运行。<br>服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。</p>
<span id="more"></span>
<h2 id="常用的命令："><a href="#常用的命令：" class="headerlink" title="常用的命令："></a>常用的命令：</h2><h3 id="查询设备"><a href="#查询设备" class="headerlink" title="查询设备"></a>查询设备</h3><p>在发出adb命令之前，了解哪些设备实例已经了解到adb服务器会很有帮助<br>adb devices -l</p>
<h3 id="将命令发送至特定设备"><a href="#将命令发送至特定设备" class="headerlink" title="将命令发送至特定设备"></a>将命令发送至特定设备</h3><p>如果有多个命令正在运行，发出adb命令时必须指定目标设备。为此，请使用devices命令获取目标设备的序列号。获得序列号时，请结合-s选项和adb命令来指定序列号。<br>adb -s xxxxxxxxx installl helloworld.apk</p>
<h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><p>使用adb的install命令在模拟器或链接的设备上安装APK<br>adb install path_to_apk</p>
<h3 id="设置端口转发"><a href="#设置端口转发" class="headerlink" title="设置端口转发"></a>设置端口转发</h3><p>可以使用forward命令设置任意端口转发，将特定主机端口上的请求转发到设备上其他端口。以下实例设置了主机端口6100到设备端口7100的转发：<br>adb forward tcp:6100 tcp:7100</p>
<h3 id="将文件复制到设备-x2F-从设备复制文件"><a href="#将文件复制到设备-x2F-从设备复制文件" class="headerlink" title="将文件复制到设备&#x2F;从设备复制文件"></a>将文件复制到设备&#x2F;从设备复制文件</h3><p>可以使用pull和push命令将文件复制到设备或从设备复制文件。与install命令（仅将apk文件复制到特定位置）不同，使用pull和push命令可将任意目录和文件复制到设备中任何位置。<br>从设备中复制某个文件或目录（及其子目录）,使用以下命令：<br>Adb pull remote local<br>如需将某个文件或目录复制到设备，使用以下命令：<br>Adb push local remote<br>将local和remote替换为开发机器（本地）和设备（远程）上的目标文件&#x2F;目录的路径：<br>Adb push foo.txt &#x2F;sdcard&#x2F;foo.txt</p>
<h3 id="停止adb服务器"><a href="#停止adb服务器" class="headerlink" title="停止adb服务器"></a>停止adb服务器</h3><p>在某些情况下，您可能需要终止adb服务器进程，然后重启以解决问题（例如，如果adb不响应命令）。<br>如需停止adb服务器，请使用adb kill-server命令。然后，您可以通过发出其他任何adb命令来重启服务器。</p>
<h3 id="发出adb命令"><a href="#发出adb命令" class="headerlink" title="发出adb命令"></a>发出adb命令</h3><p>可以从开发机器上的命令行发出adb命令，也可以通过脚本发出，用法如下：<br>adb [-d | -e | -s  serial_number] command<br>如果只有一个模拟器在运行或者只连接了一个设备，系统会默认将adb命令发送到该设备，如果有多个模拟器在运行并且&#x2F;或者连接了多个设备，您需要使用-d、-e、-s选项指定应向其发送命令的目标设备，您可以使用以下命令来查看所有支持的adb命令的详细列表：<br>adb –help</p>
<h3 id="发出shell命令"><a href="#发出shell命令" class="headerlink" title="发出shell命令"></a>发出shell命令</h3><p>可以使用shell命令通过adb发出设备命令，也可以启交互式shell。如需发出单个命令，请使用shell命令，如下所示：<br>adb shell shell_command<br>要在设备上启动交互式shell，请使用shell命令，如下：<br>adb shell<br>要退出交互式shell，按初crtl+D或者输入exit</p>
<h3 id="从手机上导出应用软件apk文件"><a href="#从手机上导出应用软件apk文件" class="headerlink" title="从手机上导出应用软件apk文件"></a>从手机上导出应用软件apk文件</h3><p>第一步：查看app包名<br>adb shell ammonitor<br>这个时候点击运行手机上要看的包名的app，就可以看到启动的包名了<br>第二步：查看包存放的路径<br>adb shell pm path com.eda.abcd<br>这个时候就可以看到该应用程序的包存放路径<br>第三步：使用adb pull + 包存放路径<br>将apk导出到电脑</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android工程项目结构解析</title>
    <url>/2022/11/10/Android%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>android工程的重点目录解析</p>
<span id="more"></span>

<p><img src="https://s3.bmp.ovh/imgs/2022/11/10/7b843f31f0a99719.png"></p>
<p>接下来对关键部分进行讲解：<br>Java，我们写Java代码的地方，业务功能都在这里实现<br>res，我们存放各种资源文件的地方，有图片，字符串，动画，音频，还有各种形式的xml文件</p>
<h1 id="一、res资源文件夹介绍："><a href="#一、res资源文件夹介绍：" class="headerlink" title="一、res资源文件夹介绍："></a>一、res资源文件夹介绍：</h1><p>注：说道这个res目录，另外还有一个assets目录，虽然这里没有，但是我们可以自己创建，两者的区别在于是否前者下所有的资源文件都会在R.java文件下生成对应的资源id，而后者并不会；前者我们可以通过资源id访问到对应的资源；而后者则需要我们通过AssetManager以二进制的形式来读取了。这个R文件可以理解为字典，res下每个资源都会在这里生成一个唯一的id。<br>分辨率不同的系统会根据屏幕的分辨率来选择hdpi,mdpi,xmdpi,xxhdpi下的对应图片，所以你解压别人的apk可以看到上述目录统一名称的图片，在四个文件夹下都有，只是大小和像素不一样而已，当然，这也不是绝对的，比如我们把所有图片都丢到hdpi下的话，本该加载ldpi文件夹下的图片资源，但是ldpi下没有，那么加载的还会使hdpi下的图片，另外还有一种情况，比如hdpi，mdpi目录下有ldpi下没有，那么会加载mdpi中的资源！原则是使用最接近密度级别，另外如果你想禁止android不跟随屏幕密度加载不同文件夹的资源，只需在AndroidManifest.xml文件中添加android:anyDensity&#x3D;”false”字段即可。</p>
<h2 id="1-图片资源"><a href="#1-图片资源" class="headerlink" title="1.图片资源"></a>1.图片资源</h2><ul>
<li>drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件</li>
<li>mipmap-hdpi：高分辨率，一般我们把图片丢这里</li>
<li>mipmap-mdpi：中等分辨率，很少，除非兼容的的手机很旧</li>
<li>mipmap-xhdpi：超高分辨率，手机屏幕材质越来越好，以后估计会慢慢往这里过渡</li>
<li>mipmap-xxhdpi：超超高分辨率，这个在高端机上有所体现</li>
</ul>
<h2 id="2-布局资源"><a href="#2-布局资源" class="headerlink" title="2.布局资源"></a>2.布局资源</h2><ul>
<li>layout：该目录下存放的就是我们的布局文件，另外在一些特定的机型上，我们做屏幕适配，比如480*320这样的手机，我们会另外创建一套布局，就行：layout-480x320这样的文件夹！</li>
</ul>
<h2 id="3-菜单资源"><a href="#3-菜单资源" class="headerlink" title="3.菜单资源"></a>3.菜单资源</h2><ul>
<li>menu：在以前有物理菜单按钮，即menu键的手机上，用的较多，现在用的并不多，菜单项相关的资源xml可在这里编写，不知道谷歌会不会出新的东西来替代菜单了~</li>
</ul>
<h2 id="4-values目录"><a href="#4-values目录" class="headerlink" title="4.values目录"></a>4.values目录</h2><ul>
<li>demens.xml：定义尺寸资源</li>
<li>string.xml：定义字符串资源</li>
<li>styles.xml：定义样式资源</li>
<li>colors.xml：定义颜色资源</li>
<li>arrays.xml：定义数组资源</li>
<li>attrs.xml：自定义控件时用的较多，自定义控件的属性！</li>
<li>theme主题文件，和styles很相似，但是会对整个应用中的Actvitiy或指定Activity起作用，一般是改变窗口外观的！可在Java代码中通过setTheme使用，或者在Androidmanifest.xml中为&lt;application…&gt;添加theme的属性！ PS:你可能看到过这样的values目录：values-w820dp，values-v11等，前者w代表平板设备，820dp代表屏幕宽度；而v11这样代表在API(11)，即android 3.0后才会用到的！</li>
</ul>
<h2 id="5-raw目录"><a href="#5-raw目录" class="headerlink" title="5.raw目录"></a>5.raw目录</h2><p>用于存放各种原生资源（音频，视频，一些XML文件等），我们可以通过openRawResource(int id)来获得资源的二进制流，其实和Assets差不多，不过这里面的资源会在R文件里生成一个资源id而已<br>6.最后还有动画的，动画有两种：属性动画和补间动画</p>
<ul>
<li>animator：存放属性动画的XML文件</li>
<li>anim：存放补间动画的XML文件</li>
</ul>
<h1 id="二、深入了解三个文件"><a href="#二、深入了解三个文件" class="headerlink" title="二、深入了解三个文件"></a>二、深入了解三个文件</h1><p>工程中三个比较重要的文件：MainActivity.java， 布局文件：activity_main.xml和配置文件AndroidMainfest.xml<br>代码分析：</p>
<p>MainAcitivity.java<br><img src="https://s3.bmp.ovh/imgs/2022/11/10/48c14edb5816ca14.png"><br>activity_main.xml：<br><img src="https://s3.bmp.ovh/imgs/2022/11/10/e8bfda21011a2f54.png"><br>AndroidMainfest.xml配置文件：<br><img src="https://s3.bmp.ovh/imgs/2022/11/10/d4a0c330f888bfbe.png"><br>①如果app包含其他组件的话,都要使用类型说明语法在该文件中进行声明 Server:<br>②权限的声明: 在该文件中显式地声明程序需要的权限,防止app错误地使用服务, 不恰当地访问 资源,最终提高android app的健壮性 android.permission.SEND_SMS 有这句话表示app需要使用发送信息的权限,安装的时候就会提示用户, 相关权限可以在sdk参考手册查找！</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android横竖屏切换以及对应布局加载</title>
    <url>/2022/11/10/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>如果要让软件在横竖屏之间切换，由于横竖屏的宽高会发生转换，有可能会要求不同的布局。</p>
<span id="more"></span>
<h1 id="1-横竖屏切换连带横竖屏布局问题："><a href="#1-横竖屏切换连带横竖屏布局问题：" class="headerlink" title="1.横竖屏切换连带横竖屏布局问题："></a>1.横竖屏切换连带横竖屏布局问题：</h1><p>如果要让软件在横竖屏之间切换，由于横竖屏的宽高会发生转换，有可能会要求不同的布局。<br>可以通过一下两种方法切换布局：<br>1）在res目录下建立layout-land和layout-port目录，相应的layout文件名不变，比如：layout-land是横屏的，layout-port是竖屏的时候，其他的不用管，横竖屏切换时程序调用Activity的onCreate方法中的setOnContent(xxx)，并自动加载相应的布局。<br>2）假如布局资源不按照如上设置，则可以通过Java代码来判断当前是横屏还是竖屏然后来加载相应的xml布局文件。因为当屏幕变为横屏的时候，系统会重新加载当前Activity的onCreate方法（也就是说：该Activity的声明周期要重头开始），你可以把以下方法放在你的onCreate中来检查当前的方法，然后可以让你的setContentVIew来载入不同的layout</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Private int orientation;</span><br><span class="line">Orientation = getResources().getConfiguration().orientation;</span><br></pre></td></tr></table></figure>
<h1 id="2-强制设定屏幕的横竖屏方向"><a href="#2-强制设定屏幕的横竖屏方向" class="headerlink" title="2.强制设定屏幕的横竖屏方向"></a>2.强制设定屏幕的横竖屏方向</h1><p>android横竖屏切换在手机开发中比较常见，很多软件在开发过程中为了避免横竖屏切换时引发不必要的麻烦，通常要强制设置横竖屏的方向，通过在androidMainfest.xml中设置activity中的android:screenOrientation属性值来实现。<br>比如下列设置：<br>横屏显示设置，android:screenOrientation&#x3D;”landscape”<br>竖屏显示设置，android:screenOrientation&#x3D;”portrait”<br>当然上述修改也可以在Java代码中通过代码实现：（android屏幕的切换会重启Activity，所以在Activity销毁前保存当前活动的状态，并在Activity再次Create的时候载入配置）<br>setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)</p>
<h1 id="3-拦截横竖屏切换-需要的配置文件：onConfigurationChanged"><a href="#3-拦截横竖屏切换-需要的配置文件：onConfigurationChanged" class="headerlink" title="3.拦截横竖屏切换 需要的配置文件：onConfigurationChanged"></a>3.拦截横竖屏切换 需要的配置文件：onConfigurationChanged</h1><p>Activity每次横竖屏切换都会重新调用onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onResume（为此内容和数据要保存和读取，否则转屏之前内容将就会消失了）<br>很多时候这样的结果让程序繁琐，为此android提供了在mainfest中设置android:configChanges属性，从而让activity不延续上述的重建流程；<br>方式一：在android工程的Mainfest.xml中配置activity：android:configChanges&#x3D;”keyboardHidden|orientation”，横竖屏切换之后就不会去执行OnCreate函数了，而是会去调用onConfigurationChanged()这样就能控制横竖屏的切换了。<br>方式二：用户可以在Activity或View的：onConfigurationChanged(configuration config)，函数中获取当前横竖屏参数，至于其调用顺序跟touch时间的传递顺序相似，不过他没有消费事件的概念，会顺次调用到每一个onConfigurationChanged函数。<br>需要重写Activity的onConfigurationChanged方法。实现方式如下，不需要做太多的内容：<br>需要注意的是，onConfigurationChanged函数中只能获得横竖屏切换后的参数，在该函数中获取不到新的Layout和控件尺寸位置信息，如果要处理尺寸和位置信息，必须通过消息异步或者延时调用；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"></span><br><span class="line">       public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class="line"></span><br><span class="line">               super.onConfigurationChanged(newConfig);</span><br><span class="line"></span><br><span class="line">               if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line"></span><br><span class="line">                       // land do nothing is ok</span><br><span class="line"></span><br><span class="line">               &#125; else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line"></span><br><span class="line">                       // port do nothing is ok</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-自适应切换屏幕："><a href="#4-自适应切换屏幕：" class="headerlink" title="4.自适应切换屏幕："></a>4.自适应切换屏幕：</h1><p>如果想让它启动的时候是横屏的话就横屏表示，纵屏的话就纵屏表示，然后手机切换横竖屏就不能用了该怎么解决呢？<br>首先：在Mainfest.xml中追加android:screenOrientation&#x3D;”sensor”<br>android:configurationChanges&#x3D;”orientation|keyboardHidden”<br>然后：取得屏幕的长和宽，进行比较设置横竖屏的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Display display = getWindowManager().getDefaultDisplay();</span><br><span class="line">    int width = display.getWidth();</span><br><span class="line">    int height = display.getHeight();</span><br><span class="line">    if (width &gt; height) &#123;</span><br><span class="line">      orientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE; // 横屏</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      orientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT; // 竖屏</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">然后：在onConfigurationChanged()函数中追加this.setRequestedOrientation(orientation)</span><br><span class="line">public void onConfigurationChanged(Configuration newConfig) &#123; </span><br><span class="line">         super.onConfigurationChanged(newConfig); </span><br><span class="line">         this.setRequestedOrientation(orientation); </span><br><span class="line">       &#125; </span><br></pre></td></tr></table></figure>
<p>但是这样的话你切到别的画面的时候再回到原画面，它就仍然是横的或者是纵的。怎么让它从别的屏幕回来后，又重新横竖屏布局呢？<br>只要在onResume()中再设定下就行了，但是这个仅仅只是支持横竖屏只有一个layout的；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onResume() &#123;</span><br><span class="line">    orientation = ActivityInfo.SCREEN_ORIENTATION_USER;</span><br><span class="line">    this.setRequestedOrientation(orientation);</span><br><span class="line">    Display display = getWindowManager().getDefaultDisplay();</span><br><span class="line">    int width = display.getWidth();</span><br><span class="line">    int height = display.getHeight();</span><br><span class="line">    if (width &gt; height) &#123;</span><br><span class="line">      orientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      orientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;</span><br><span class="line">    &#125;</span><br><span class="line">    super.onResume();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>有三点注意：<br>1.不设置activity的android:confiChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次<br>2.设置Activity的android:configChanges&#x3D;”orientation”时，切屏还是会重新调用各个生命周期，切横竖屏时只会执行一次<br>3.设置activity的android:configChanges&#x3D;”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android文件管理</title>
    <url>/2022/12/07/Android%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-Android文件的操作模式"><a href="#1-Android文件的操作模式" class="headerlink" title="1.Android文件的操作模式"></a>1.Android文件的操作模式</h2><p>Android和其他的操作系统不一样，它是基于Linux的，在读写文件的时候，还需要加上文件的操作模式，Android中的操作模式如下：</p>
<span id="more"></span>
<p>1）MODE_PRIVATE ——&gt; 默认操作模式，代表该文件是私有数据，只能够被本应用本身访问，写入的内容会覆盖原文件的内容<br>2）MODE_APPEND ——&gt; 会检验文件是否存在，存在的话往文件中追加内容，否则建立新文件<br>3）MODE_WORLD_READABLE ——&gt; 当前文件可以被其他应用读取<br>4）MODE_WORLD_WRITEABLE ——&gt; 当前文件可以被其他应用写入<br>后面两个适用于控制其他应用是否有读写文件得权限得<br>如果文件既可以写，又可以读的话，可以写成下面的形式：<br>openFileOutput(“jay123.txt”, Content.MODE_WORLD_READABLE + Content.MODE_WORLD_WRITEABLE);</p>
<h2 id="2-文件操作的相关方法"><a href="#2-文件操作的相关方法" class="headerlink" title="2.文件操作的相关方法"></a>2.文件操作的相关方法</h2><p><a href="https://imgse.com/i/zh3Gz4"><img src="https://s1.ax1x.com/2022/12/11/zh3Gz4.png" alt="zh3Gz4.png"></a></p>
<h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h2><p>首先是布局文件：main_activity.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.FileActivity&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;@string/nametitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=&quot;@+id/editname&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;@string/detailtitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=&quot;@+id/editdetail&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:minLines=&quot;2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/btnsave&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@string/btnwrite&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/btnclean&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@string/btnclean&quot; /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btnread&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;@string/btnread&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>然后再写一个文件协助类：FileHelper.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.thefu.androidstudyproject;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOError;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileHelper &#123;</span><br><span class="line"></span><br><span class="line">    private Context context;</span><br><span class="line"></span><br><span class="line">    public FileHelper() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FileHelper(Context context) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里定义的是一个文件保存的方法，写入到文件中，所以是输出流</span><br><span class="line">     * @param fileName</span><br><span class="line">     * @param fileContent</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public void save(String fileName, String fileContent) throws Exception &#123;</span><br><span class="line">        //这里使用私有模式，创建出来的文件只能被本应用访问，还会覆盖原文件</span><br><span class="line">        FileOutputStream output = context.openFileOutput(fileName, Context.MODE_PRIVATE);</span><br><span class="line">        output.write(fileContent.getBytes()); //将String字符串以字节的形式写入到输出流中</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里定义的是文件读取的方法</span><br><span class="line">     * @param fileName</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public String read(String fileName) throws IOException &#123;</span><br><span class="line">        //打开文件输入流</span><br><span class="line">        FileInputStream input = context.openFileInput(fileName);</span><br><span class="line">        byte[] temp = new byte[1024];</span><br><span class="line">        StringBuilder sb = new StringBuilder(&quot;&quot;);</span><br><span class="line">        int len = 0;</span><br><span class="line">        //读取文件内容</span><br><span class="line">        while ((len = input.read(temp)) &gt; 0) &#123;</span><br><span class="line">            sb.append(new String(temp, 0, len));</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭输入流</span><br><span class="line">        input.close();</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是Activity，在这里我们完成相关操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.thefu.androidstudyproject;</span><br><span class="line"></span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line">import android.widget.EditText;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FileActivity extends AppCompatActivity implements View.OnClickListener&#123;</span><br><span class="line"></span><br><span class="line">    private EditText editname;</span><br><span class="line">    private EditText editdetail;</span><br><span class="line">    private Button btnsave;</span><br><span class="line">    private Button btnclean;</span><br><span class="line">    private Button btnread;</span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_file);</span><br><span class="line">        mContext = getApplicationContext();</span><br><span class="line">        bindView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bindView() &#123;</span><br><span class="line">        editdetail = (EditText) findViewById(R.id.editdetail);</span><br><span class="line">        editname = (EditText) findViewById(R.id.editname);</span><br><span class="line">        btnclean = (Button) findViewById(R.id.btnclean);</span><br><span class="line">        btnsave = (Button) findViewById(R.id.btnsave);</span><br><span class="line">        btnread = (Button) findViewById(R.id.btnread);</span><br><span class="line"></span><br><span class="line">        btnclean.setOnClickListener(this);</span><br><span class="line">        btnsave.setOnClickListener(this);</span><br><span class="line">        btnread.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        switch (view.getId()) &#123;</span><br><span class="line">            case R.id.btnclean:</span><br><span class="line">                editdetail.setText(&quot;&quot;);</span><br><span class="line">                editname.setText(&quot;&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case R.id.btnsave:</span><br><span class="line">                FileHelper fHelper = new FileHelper(mContext);</span><br><span class="line">                String filename = editname.getText().toString();</span><br><span class="line">                String filedetail = editdetail.getText().toString();</span><br><span class="line">                try &#123;</span><br><span class="line">                    fHelper.save(filename, filedetail);</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;数据写入成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;数据写入失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case R.id.btnread:</span><br><span class="line">                String detail = &quot;&quot;;</span><br><span class="line">                FileHelper fHelper2 = new FileHelper(getApplicationContext());</span><br><span class="line">                try &#123;</span><br><span class="line">                    String fname = editname.getText().toString();</span><br><span class="line">                    detail = fHelper2.read(fname);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                Toast.makeText(getApplicationContext(), detail, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-读取SD卡上的文件"><a href="#4-读取SD卡上的文件" class="headerlink" title="4.读取SD卡上的文件"></a>4.读取SD卡上的文件</h2><p><a href="https://imgse.com/i/zh3BFK"><img src="https://s1.ax1x.com/2022/12/11/zh3BFK.png" alt="zh3BFK.png"></a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android developer 必备的几个资源</title>
    <url>/2023/02/22/Android-developer-%E5%BF%85%E5%A4%87%E7%9A%84%E5%87%A0%E4%B8%AA%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>作为一名合格的 Android Coder，除了认真工作，写出优秀代码外，我们还需要在日新月异的技术栈中找到有用的资源，来装备自己，开阔视野。希望以下的资源对大家有用。</p>
<span id="more"></span>

<h2 id="1-官方资源"><a href="#1-官方资源" class="headerlink" title="1.官方资源"></a>1.官方资源</h2><p>一手、最新、最全的资料。<br><a href="https://imgse.com/i/p9ZShM8"><img src="https://s1.ax1x.com/2023/04/22/p9ZShM8.png" alt="p9ZShM8.png"></a><br>包含 Android Platform、Android Studio、Jetpack、Kotlin 等一切跟 Android 开发相关的指导、例子Sample 等。大部分人肯定都知道。<br>建议每隔一段时间上去看看，经常更新，比如最近增加了模块化的指导。除此之外，其他架构相关的内容，不管是初学者还是初学者，<br>都有很多指导、学习的意义。</p>
<p>其他官方资源，比如：</p>
<ul>
<li>Android Developers on Medium <a href="https://medium.com/androiddevelopers">https://medium.com/androiddevelopers</a></li>
<li>Android Developers on YouTube <a href="https://www.youtube.com/@AndroidDevelopers">https://www.youtube.com/@AndroidDevelopers</a></li>
<li>Google Codelabs <a href="https://codelabs.developers.google.com/?product=android">https://codelabs.developers.google.com/?product=android</a></li>
</ul>
<p>网址：<a href="https://developer.android.com/docs">https://developer.android.com/docs</a></p>
<h2 id="2-Android-Weekly"><a href="#2-Android-Weekly" class="headerlink" title="2.Android Weekly"></a>2.Android Weekly</h2><p><a href="https://imgse.com/i/p9ZprlV"><img src="https://s1.ax1x.com/2023/04/22/p9ZprlV.png" alt="p9ZprlV.png"></a><br>聚合了最近、最新的 Android 相关的文章、开源项目、视频&amp;播客、新闻等，每周一更新，不容错过。</p>
<p>网址：<a href="https://androidweekly.net/">https://androidweekly.net/</a></p>
<h2 id="3-kotlin-Weekly"><a href="#3-kotlin-Weekly" class="headerlink" title="3.kotlin Weekly"></a>3.kotlin Weekly</h2><p><a href="https://imgse.com/i/p9Zpgw4"><img src="https://s1.ax1x.com/2023/04/22/p9Zpgw4.png" alt="p9Zpgw4.png"></a><br>类似于上面的 Android Weekly，主要提供一些 kotlin 相关技术栈更新、文章、新特性等，也包括了一些 Android 相关的内容。</p>
<p>网址：<a href="http://www.kotlinweekly.net/">http://www.kotlinweekly.net/</a></p>
<h2 id="4-ProAndroidDev"><a href="#4-ProAndroidDev" class="headerlink" title="4.ProAndroidDev"></a>4.ProAndroidDev</h2><p><a href="https://imgse.com/i/p9Zphf1"><img src="https://s1.ax1x.com/2023/04/22/p9Zphf1.png" alt="p9Zphf1.png"></a><br>Medium（国外的简书）上的一个组织，都是 Android专家和大牛（Google Developer Experts）写的一些易懂、简洁的文章，质量不错。而且，如果你要在该专栏发布文章的话，需要专家 review 才能发出来。</p>
<p>网址：<a href="https://proandroiddev.com/">https://proandroiddev.com/</a></p>
<h2 id="5-Github"><a href="#5-Github" class="headerlink" title="5.Github"></a>5.Github</h2><p>这个应该都知道吧，最大的基友交流社区，全世界的代码仓库集中地。<br>比如 Android 官方的仓库，<a href="https://github.com/android%EF%BC%8C%E5%8C%85%E5%90%AB%E5%BE%88%E5%A4%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E6%AF%94%E5%A6%82">https://github.com/android，包含很多最佳实践，比如</a> Now In Android, architecture-samples,  sunflower 等。<br>也可以通过 GitHub Trending page 来查看最近热门的仓库，类似微博热搜🔥 （筛选 kotlin 语言，前几个就是 android 相关的项目）<br>顺便推荐一个 android-developer-roadmap 项目，包含了一些 Android 开发的资源：<br><a href="https://imgse.com/i/p9Zpo6K"><img src="https://s1.ax1x.com/2023/04/22/p9Zpo6K.png" alt="p9Zpo6K.png"></a></p>
<h2 id="6-Google-Developer-Library"><a href="#6-Google-Developer-Library" class="headerlink" title="6.Google Developer Library"></a>6.Google Developer Library</h2><p>又是一个宝藏资源库！<br>谷歌官方的资源库，包含了 Android、Flutter、Firebase 和 Machine Learning 等资源，光 Android 方面就有一大堆，打开慢慢看吧<br><a href="https://imgse.com/i/p9ZpOkd"><img src="https://s1.ax1x.com/2023/04/22/p9ZpOkd.png" alt="p9ZpOkd.png"></a></p>
<h2 id="7-Android-Arsenal"><a href="#7-Android-Arsenal" class="headerlink" title="7.Android Arsenal"></a>7.Android Arsenal</h2><p>安卓军火库，聚集了大量的开源库，工具等，支持分类查找。<br>也可以提交自己的开源库，通过审核就可以展示出来，供别人使用。<br>关注它的推特，及时获取最新的开源项目。</p>
<p>网址：<a href="https://android-arsenal.com/">https://android-arsenal.com/</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开发调用C++库</title>
    <url>/2023/01/15/Android-%E5%BC%80%E5%8F%91%E8%B0%83%E7%94%A8C++%E5%BA%93/</url>
    <content><![CDATA[<p>背景：实际项目中的算法库很多都是C++代码编写的，而Android开发是使用kotlin或者java语言实现的，如果遇到一个APP需要调用算法库，<br>不同语言有不同的书写规范，直接引用当然不可能编译成功，因此我们需要通过中间层（JNI编程）来搭建java语言和C++语言沟通的桥梁。</p>
<span id="more"></span>

<h2 id="一、新建使用JNI编程的工程"><a href="#一、新建使用JNI编程的工程" class="headerlink" title="一、新建使用JNI编程的工程"></a>一、新建使用JNI编程的工程</h2><p>在android studio中，新建一个native C++的工程<br><a href="https://imgse.com/i/p9VvgP0"><img src="https://s1.ax1x.com/2023/04/22/p9VvgP0.png" alt="p9VvgP0.png"></a><br>设置项目和包的名称（包的名称需要和你自己实际使用的项目包名一致，否则就只能通过模块的方式去调用）<br><a href="https://imgse.com/i/p9VvR2T"><img src="https://s1.ax1x.com/2023/04/22/p9VvR2T.png" alt="p9VvR2T.png"></a></p>
<h2 id="二、下载JNI开发所需的NKD，LLDB，CMake工具包"><a href="#二、下载JNI开发所需的NKD，LLDB，CMake工具包" class="headerlink" title="二、下载JNI开发所需的NKD，LLDB，CMake工具包"></a>二、下载JNI开发所需的NKD，LLDB，CMake工具包</h2><p>打开Androidstudio -&gt; Preferences -&gt; Android SDK<br><a href="https://imgse.com/i/p9VvhMF"><img src="https://s1.ax1x.com/2023/04/22/p9VvhMF.png" alt="p9VvhMF.png"></a><br>JNI：Java Native Interface（java本地编程接口），一套编程规范，它提供了若干的API，实现了Java和其他语言的通信（主要是C&#x2F;C++）<br>NDK：Native Development Kit（本地开发工具），一系列工具的集合，这套工具允许你在Android开发中使用C和C++代码<br>CMake：跨平台编译工具<br>LLDB：一种调试程序，Android Studio使用它来调试原生代码</p>
<h2 id="三、在cpp文件夹下防止需被打包的C-x2F-C-源码，CMakeLists里添加所有C-x2F-C-代码和native-lib-cpp：如图，inc里放置头文件，src里放置-c-x2F-cpp文件（注意修改引用路径）"><a href="#三、在cpp文件夹下防止需被打包的C-x2F-C-源码，CMakeLists里添加所有C-x2F-C-代码和native-lib-cpp：如图，inc里放置头文件，src里放置-c-x2F-cpp文件（注意修改引用路径）" class="headerlink" title="三、在cpp文件夹下防止需被打包的C&#x2F;C++源码，CMakeLists里添加所有C&#x2F;C++代码和native-lib.cpp：如图，inc里放置头文件，src里放置.c&#x2F;.cpp文件（注意修改引用路径）"></a>三、在cpp文件夹下防止需被打包的C&#x2F;C++源码，CMakeLists里添加所有C&#x2F;C++代码和native-lib.cpp：如图，inc里放置头文件，src里放置.c&#x2F;.cpp文件（注意修改引用路径）</h2><p><a href="https://imgse.com/i/p9VvoZ9"><img src="https://s1.ax1x.com/2023/04/22/p9VvoZ9.png" alt="p9VvoZ9.png"></a></p>
<h2 id="四、新建一个工具类，在类中声明需要调用的方法。（这一步设计类型转换C-gt-JNI-gt-JAVA）"><a href="#四、新建一个工具类，在类中声明需要调用的方法。（这一步设计类型转换C-gt-JNI-gt-JAVA）" class="headerlink" title="四、新建一个工具类，在类中声明需要调用的方法。（这一步设计类型转换C++ -&gt; JNI -&gt; JAVA）"></a>四、新建一个工具类，在类中声明需要调用的方法。（这一步设计类型转换C++ -&gt; JNI -&gt; JAVA）</h2><p><a href="https://imgse.com/i/p9Vv7I1"><img src="https://s1.ax1x.com/2023/04/22/p9Vv7I1.png" alt="p9Vv7I1.png"></a></p>
<h2 id="五、在native-lib-cpp里实现方法从C-到JNI的转换"><a href="#五、在native-lib-cpp里实现方法从C-到JNI的转换" class="headerlink" title="五、在native-lib.cpp里实现方法从C++到JNI的转换"></a>五、在native-lib.cpp里实现方法从C++到JNI的转换</h2><p><a href="https://imgse.com/i/p9VxFRf"><img src="https://s1.ax1x.com/2023/04/22/p9VxFRf.png" alt="p9VxFRf.png"></a></p>
<h2 id="六、执行Build-gt-Make-Project，可得到-so文件"><a href="#六、执行Build-gt-Make-Project，可得到-so文件" class="headerlink" title="六、执行Build -&gt; Make Project，可得到.so文件"></a>六、执行Build -&gt; Make Project，可得到.so文件</h2><p><a href="https://imgse.com/i/p9Vxkz8"><img src="https://s1.ax1x.com/2023/04/22/p9Vxkz8.png" alt="p9Vxkz8.png"></a></p>
<h2 id="七、把-so库放入需要算法库的工程下"><a href="#七、把-so库放入需要算法库的工程下" class="headerlink" title="七、把.so库放入需要算法库的工程下"></a>七、把.so库放入需要算法库的工程下</h2><p><a href="https://imgse.com/i/p9VxmZj"><img src="https://s1.ax1x.com/2023/04/22/p9VxmZj.png" alt="p9VxmZj.png"></a></p>
<h2 id="八、在新工程中，同一报名目录下新建名字相同的类，复写加载和声明函数"><a href="#八、在新工程中，同一报名目录下新建名字相同的类，复写加载和声明函数" class="headerlink" title="八、在新工程中，同一报名目录下新建名字相同的类，复写加载和声明函数"></a>八、在新工程中，同一报名目录下新建名字相同的类，复写加载和声明函数</h2><p><a href="https://imgse.com/i/p9Vxo6S"><img src="https://s1.ax1x.com/2023/04/22/p9Vxo6S.png" alt="p9Vxo6S.png"></a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Android sharesheet在Android应用程序中分享内容和链接</title>
    <url>/2023/03/22/%E4%BD%BF%E7%94%A8Android-sharesheet%E5%9C%A8Android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%86%E4%BA%AB%E5%86%85%E5%AE%B9%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>为何要使用Android sharesheet<br>主要有三点原因：</p>
<ol>
<li>谷歌官方推荐使用</li>
<li>Target SDK 30 以上，包名可见性发生了变更，默认情况下，应用与应用是不可见的，换句话说，如果使用queryIntentActivities()方法，不一定能够获取到所有intent对应的activity，这样就给分享intent造成了麻烦。</li>
<li>Android sharesheet提供了包括界面、结果收集、固定前置和屏蔽指定app在内的全套功能，可以节省设计和开发资源<span id="more"></span></li>
</ol>
<h2 id="使用Android-sharesheet的基础步骤"><a href="#使用Android-sharesheet的基础步骤" class="headerlink" title="使用Android sharesheet的基础步骤"></a>使用Android sharesheet的基础步骤</h2><p>Android sharesheet的使用十分简单，大致分为两个步骤：准备intent，使用intent调起分享弹窗。<br>将会使用3个例子来展现sharesheet的使用，本别是：分享一段文字(可以包含某个链接)，分享一个视频，分享多个视频</p>
<h3 id="准备intent："><a href="#准备intent：" class="headerlink" title="准备intent："></a>准备intent：</h3><h3 id="分享一段文字："><a href="#分享一段文字：" class="headerlink" title="分享一段文字："></a>分享一段文字：</h3><p>如果只是想分享一段文字，并且文字中包含了一个跳转链接，是比较简单的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//linkWtihText 就是想要分享的文字，实际使用时常常包含一段跳转链接</span><br><span class="line">val sendIntent: Intent = Intent().apply &#123;</span><br><span class="line">    action = Intent.ACTION_SEND</span><br><span class="line">    putExtra(Intent.EXTRA_TEXT, linkWtihText)</span><br><span class="line">    type = &quot;text/plain&quot;</span><br><span class="line">&#125;</span><br><span class="line">//使用sendIntent来制作分享跳转使用的intent</span><br><span class="line">val shareIntent = Intent.createChooser(sendIntent, &quot;null&quot;, &quot;null&quot;)</span><br><span class="line">//添加flag</span><br><span class="line">shareIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br></pre></td></tr></table></figure>

<h3 id="分享一个视频："><a href="#分享一个视频：" class="headerlink" title="分享一个视频："></a>分享一个视频：</h3><p>其实质是分享一个视频媒体文件，所以分享一个音乐、一张图片等也是类似的步骤。首先，我们需要制作一个待分享的文件的uri，此处使用FileProvider：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//把路径转换成可以用来分享的Uri，path：待分享的文件路径</span><br><span class="line">private fun createFileUriWithPath(context: Context, path: String): Uri &#123;</span><br><span class="line">    val shareFile = File(path)</span><br><span class="line">    return FileProvider.getUriForFile(</span><br><span class="line">        context,</span><br><span class="line">        &quot;com.miui.localvideoplayer.shareprovider&quot;,</span><br><span class="line">        shareFile</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，基于以上方法制作的uri，制作分享intent：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val shareUri = createFileUriWithPath(appContext, path)</span><br><span class="line">val sendIntent = Intent()</span><br><span class="line">sendIntent.action = Intent.ACTION_SEND</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_STREAM, shareUri)</span><br><span class="line">sendIntent.data = shareUri</span><br><span class="line">//此处需要对uri赋予可读取的权限</span><br><span class="line">sendIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)</span><br><span class="line">sendIntent.type = &quot;video/*&quot;</span><br><span class="line">//使用sendIntent来制作分享跳转使用的intent</span><br><span class="line">val shareIntent = Intent.createChooser(sendIntent, &quot;null&quot;, &quot;null&quot;)</span><br><span class="line">//添加flag</span><br><span class="line">shareIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br></pre></td></tr></table></figure>

<h3 id="分享多个视频："><a href="#分享多个视频：" class="headerlink" title="分享多个视频："></a>分享多个视频：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//shareList: ArrayList&lt;String&gt; 待分享的文件路径列表</span><br><span class="line"></span><br><span class="line">if (shareList.size == 1) &#123;</span><br><span class="line">    //如果列表中只有一个文件，那么请将其当作单个文件分享，以获取更多的接受方</span><br><span class="line">    shareSingleVideoFile(context, shareList[0])</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val shareUriList = java.util.ArrayList&lt;Uri&gt;()</span><br><span class="line">for (path in shareList) &#123;</span><br><span class="line">    //仍然需要用到上文提到的制作uri的方法，将uri们保存在一个list里</span><br><span class="line">    val shareUri = createFileUriWithPath(appContext, path)</span><br><span class="line">    shareUriList.add(shareUri)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val sendIntent = Intent()</span><br><span class="line">//此处的action为ACTION_SEND_MULTIPLE</span><br><span class="line">sendIntent.action = Intent.ACTION_SEND_MULTIPLE</span><br><span class="line">sendIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, shareUriList)</span><br><span class="line">sendIntent.type = &quot;video/*&quot;</span><br><span class="line">sendIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)</span><br><span class="line">val shareIntent = Intent.createChooser(sendIntent, &quot;null&quot;, &quot;null&quot;)</span><br><span class="line">shareIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br></pre></td></tr></table></figure>

<h3 id="使用intent调起分享弹窗："><a href="#使用intent调起分享弹窗：" class="headerlink" title="使用intent调起分享弹窗："></a>使用intent调起分享弹窗：</h3><p>使用context.startActivity方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mContext.startActivity(shareIntent)</span><br></pre></td></tr></table></figure>

<h2 id="将某些接收端固定前置-x2F-将某些接收端屏蔽"><a href="#将某些接收端固定前置-x2F-将某些接收端屏蔽" class="headerlink" title="将某些接收端固定前置&#x2F;将某些接收端屏蔽"></a>将某些接收端固定前置&#x2F;将某些接收端屏蔽</h2><p>在实际的使用中，我们经常想要将某些应用前置在我们的分享弹窗中，例如，我希望用户把我们的链接分享到facebook,whatsapp,messenger,telegram中，这样可以方便我们进行裂变转播，sharesheet也可以做到。<br>实现方法也十分简单，只要给shareInent增加一个key为Intent.EXTRA_INITIAL_INTENTS的extra，并且往里传入一个sendIntent的typedArray，就可以了<br>首先，制作需要前置分享的app的intent list</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun getExtraInitialIntent(text: String): ArrayList&lt;Intent&gt; &#123;</span><br><span class="line">    val intentShareList = ArrayList&lt;Intent&gt;()</span><br><span class="line">    //需要前置的receiver app的包名</span><br><span class="line">    var shareItems = </span><br><span class="line">        arrayOf(</span><br><span class="line">            &quot;com.facebook.katana&quot;,</span><br><span class="line">            &quot;com.whatsapp&quot;,</span><br><span class="line">            &quot;com.facebook.orca&quot;,</span><br><span class="line">            &quot;org.telegram.messenger&quot;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    for (packageName in shareItems) &#123;</span><br><span class="line">        val intent = Intent()</span><br><span class="line">        intent.action = Intent.ACTION_SEND</span><br><span class="line">        intent.type = &quot;text/plain&quot;</span><br><span class="line">        intent.setPackage(packageName)</span><br><span class="line">        intent.putExtra(Intent.EXTRA_TEXT, text)</span><br><span class="line">        intentShareList.add(intent)</span><br><span class="line">    &#125;</span><br><span class="line">    return intentShareList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将其转换为TypedArray并且携带给shareIntent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shareIntent.putExtra(</span><br><span class="line">    Intent.EXTRA_INITIAL_INTENTS,</span><br><span class="line">    getExtraInitialIntent(arrayListOf(path)).toTypedArray()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>同样的，我们也可以在sharesheet中排除某个receiver，比如，如果选择小米文档查看器作为receiver，那么它将把分享的文字内容当作一段地址来尝试读取某个文件，显然，这不符合我们的业务需求，并且会造成bug。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private fun getExtraExcludeComponents(intent: Intent): ArrayList&lt;ComponentName&gt; &#123;</span><br><span class="line">    val excludeList = ArrayList&lt;ComponentName&gt;()</span><br><span class="line">    val extraExcludedItems = arrayOf(&quot;cn.wps.xiaomi.abroad.lite&quot;)</span><br><span class="line">    val pm = FrameworkApplication.getAppContext().packageManager</span><br><span class="line">    val targets = pm.queryIntentActivities(intent, 0)</span><br><span class="line">    for (resolveInfo in targets) &#123;</span><br><span class="line">        val targetPackage = resolveInfo.activityInfo.packageName</span><br><span class="line">        val appName = resolveInfo.activityInfo.name</span><br><span class="line">        for (packageName in extraExcludedItems) &#123;</span><br><span class="line">            if (packageName.equals(targetPackage, true)) &#123;</span><br><span class="line">                excludeList.add(ComponentName(targetPackage, appName))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return excludeList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在制作shareIntent时，加入extra，使用EXTRA_EXCLUDE_COMPONENTS关键字，将其排除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shareIntent.putExtra(</span><br><span class="line">                    Intent.EXTRA_EXCLUDE_COMPONENTS,</span><br><span class="line">                    getExtraExcludeComponents(sendIntent).toTypedArray()</span><br><span class="line">                )</span><br></pre></td></tr></table></figure>

<h2 id="收集分享的结果"><a href="#收集分享的结果" class="headerlink" title="收集分享的结果"></a>收集分享的结果</h2><p>用户在点击分享后，需要在分享弹窗中选择一个渠道进行分享，例如，选择Facebook进行分享，而我们如果想要收集用户最后点击的选项，那么可以在Intent.createChooser(sendIntent, “null”, “null”)方法中传入一个广播接收器，从而可以接受用户点击后发出的广播。<br>首先，我们需要一个广播接收器类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LocalShareBroadCastReceiver : BroadcastReceiver() &#123;</span><br><span class="line">    override fun onReceive(context: Context?, intent: Intent?) &#123;</span><br><span class="line">        val clickedComponentName = intent?.getParcelableExtra&lt;ComponentName&gt;(Intent.EXTRA_CHOSEN_COMPONENT)</span><br><span class="line">        val packageName = clickedComponentName?.packageName</span><br><span class="line">        //packageName就是用户最终点选的包名，此处可以进行打点等统计操作</span><br><span class="line">        context?.unregisterReceiver(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，我们需要创建一个接收器实例，并且动态注册，之后再返回一个intentSender用于构造shareIntent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//建议将localShareBroadCastReceiver 保存成为static final常量，在每次分享操作时，检查是否被注册。多次注册广播接收器会使得用户在第二次分享的时候执行两次onReceive中的操作</span><br><span class="line">val localShareBroadCastReceiver = LocalShareBroadCastReceiver()</span><br><span class="line"></span><br><span class="line">val sender = registerShareReceiver(</span><br><span class="line">    appContext, &quot;com.videoplayer.SHARE_ACTION_LOCAL&quot;,</span><br><span class="line">    localShareBroadCastReceiver</span><br><span class="line">)</span><br><span class="line">val shareIntent = Intent.createChooser(sendIntent, &quot;null&quot;, sender)</span><br></pre></td></tr></table></figure>

<p>其中，registerShareReceiver方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun registerShareReceiver(</span><br><span class="line">    context: Context,</span><br><span class="line">    action: String,</span><br><span class="line">    receiver: BroadcastReceiver</span><br><span class="line">): IntentSender &#123;</span><br><span class="line">    val receiverIntent = Intent(action)</span><br><span class="line">    receiverIntent.putExtra(&quot;test&quot;, &quot;test&quot;)</span><br><span class="line">    val pi = PendingIntent.getBroadcast(</span><br><span class="line">        FrameworkApplication.getAppContext(),</span><br><span class="line">        10000,</span><br><span class="line">        receiverIntent,</span><br><span class="line">        //Android 12 以上，一定要加PendingIntent.FLAG_MUTABLE，不然将不会收到回调</span><br><span class="line">        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE</span><br><span class="line">    )</span><br><span class="line">    context.registerReceiver(</span><br><span class="line">        receiver,</span><br><span class="line">        IntentFilter(action)</span><br><span class="line">    )</span><br><span class="line">    return pi.intentSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前文注释中提到的，多次注册广播接收器会使得用户在第二次分享的时候执行两次onReceive中的操作，因此建议将localShareBroadCastReceiver 保存成为static final常量，在每次分享操作时，尝试反注册，保证每次分享操作仅有1个receiver进行监听。<br>Android开发者：应用数据和文件<br><a href="https://developer.android.google.cn/training/sharing">https://developer.android.google.cn/training/sharing</a> </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之碎片Fragment</title>
    <url>/2022/12/11/Android%E4%B9%8B%E7%A2%8E%E7%89%87Fragment/</url>
    <content><![CDATA[<p>安卓自3.0开始引入Fragment的概念，主要是为了能在不同分辨率的屏幕上进行更为动态和灵活的UI设计，让程序更加合理和充分利用大屏幕空间。</p>
<span id="more"></span>
<p>本篇将学习Fragment以下几个知识点：<br>Fragment概要<br>Fragment生命周期<br>加载Fragment方法</p>
<pre><code>静态加载
动态加载
</code></pre>
<p>Fragment与Activity之间通信</p>
<h3 id="1-Fragment概要"><a href="#1-Fragment概要" class="headerlink" title="1.Fragment概要"></a>1.Fragment概要</h3><p>学习Fragment的时候可以联系之前学习过的Activity，因为它们有很多相似点：都可包含布局，有自己的生命周期，Fragment可看似迷你活动。正如Fragment的名字一样–碎片，它的出现是为了解决Android碎片化，它可以作为Activity界面的组成部分，可在Activity运行中实现动态地加入、移除和交换。一个Activity中可同时出现多个Fragment，一个Fragment也可在多个Activity中使用。活动和碎片像极了夫妻，虽然紧密联系但是又有独立空间，在一起让彼此变得更好。<br><a href="https://imgse.com/i/zhthRK"><img src="https://s1.ax1x.com/2022/12/11/zhthRK.jpg" alt="zhthRK.jpg"></a></p>
<h3 id="2-Fragment生命周期"><a href="#2-Fragment生命周期" class="headerlink" title="2.Fragment生命周期"></a>2.Fragment生命周期</h3><p><a href="https://imgse.com/i/zhtose"><img src="https://s1.ax1x.com/2022/12/11/zhtose.jpg" alt="zhtose.jpg"></a><br>是不是发现Fragment和Activity的生命周期太相似了，现在只需要再介绍几个Activity中没讲过的几个新方法：<br>onAttach()：当Fragment和Activity建立关联时调用<br>onCreateView()：当Fragment创建视图的时候调用<br>onActivityCreated()：当与Fragment相关联的Activity完成onCreate()之后调用<br>onDestoryView()：当Fragment中的布局被移除的时候调用<br>onDetach()：当Fragment和Activity解除关联时调用</p>
<p>在上图中画了几条线，可以看到Fragment周期中的状态几乎都是成对出现的，所以不难理解下图几种变化下Fragment生命周期方法的调用顺序了。<br><a href="https://imgse.com/i/zhNion"><img src="https://s1.ax1x.com/2022/12/11/zhNion.jpg" alt="zhNion.jpg"></a></p>
<p>加载到Activity中Fragment在各种变化下方法的调用顺序更值得注意。需要提一句的是，Activity的FragmentManager负责调用队列中Fragment的生命周期方法，只要Fragment的状态与Activity的状态保持了同步，托管Activity的Fragment便会继续调用其他生命周期方法以继续保持Fragment与Activity的状态一致<br><a href="https://imgse.com/i/zhjBs1"><img src="https://s1.ax1x.com/2022/12/12/zhjBs1.jpg" alt="zhjBs1.jpg"></a><br>Fragment生命周期与Activity生命周期的一个关键就在于，Fragment的生命周期方法是由托管Activity而不是操作系统调用的。Activity中生命周期都是protected，而Fragment都是public，也能印证这一点，因为Activity需要调用Fragment那些方法并管理它</p>
<h3 id="3-加载Fragment方法"><a href="#3-加载Fragment方法" class="headerlink" title="3.加载Fragment方法"></a>3.加载Fragment方法</h3><p>现在来学习如何在Activity中加载Fragment<br>静态加载Fragment大致过程如图，分成四步：<br><a href="https://imgse.com/i/zhvASJ"><img src="https://s1.ax1x.com/2022/12/12/zhvASJ.jpg" alt="zhvASJ.jpg"></a><br>下面通过一个简单的例子感受Fragment静态加载到Activity的过程。<br>第一步：新建frag_layout.xml，为Fragment指定一个布局，这里简单的放一个Textview和一个Button。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MyFragment&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/text&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;这是一个Fragment&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        android:textColor=&quot;#000000&quot;</span><br><span class="line">        android:gravity=&quot;center&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/frg_btn&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;点击&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：新建一个MyFragment类并继承Fragment，这里引用Android.app包下的就可以，另一个包下主要用于兼容低版本的安卓系统。然后重写onCreateView()方法，这个方法里通过LayoutInflater的inflate()方法将刚刚定义的frag_layout布局加载进来并得到一个View，再return这个View。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                             Bundle savedInstanceState) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * resource：fragment需要加载的布局支持</span><br><span class="line">         * root：加载layout的父ViewGroup</span><br><span class="line">         * attachGroup：false表示不反悔父ViewGroup</span><br><span class="line">         */</span><br><span class="line">        return inflater.inflate(R.layout.fragment_my, container, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：新建main.xml，作为Activity的布局，使用&lt;fragment&gt;标签添加碎片，并且一定要有android:name属性且值为被加载的Fragment类的包名.类名完整形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.FragmentActivity&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=&quot;@+id/layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--这是静态调用的方式--&gt;</span><br><span class="line">        &lt;fragment</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:id=&quot;@+id/fragment&quot;</span><br><span class="line">            android:name=&quot;com.thefu.androidstudyproject.MyFragment&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>第四步：再MainActivity中加载main布局，现在MyFragment就完成了静态加载到MainActivity中，这时碎片里的控件自然也是活动的一个部分，可直接再活动中获取到Button的实例，来注册点击事件了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Button frag_btn;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        //静态加载</span><br><span class="line">        setContentView(R.layout.activity_ftagment);</span><br><span class="line">        frag_btn = findViewById(R.id.frg_btn);</span><br><span class="line">        frag_btn.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                Toast.makeText(FragmentActivity.this, &quot;您点击了按钮&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="（2）动态加载：在托管Activity通过代码动态添加"><a href="#（2）动态加载：在托管Activity通过代码动态添加" class="headerlink" title="（2）动态加载：在托管Activity通过代码动态添加"></a>（2）动态加载：在托管Activity通过代码动态添加</h2><p>动态加载的代码也非常简单，直接看例子，修改main.xml，将整个&lt;fragment&gt;删掉。但害保留一个LinearLayout的空间并且还给了id。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.FragmentActivity&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=&quot;@+id/layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--这是静态调用的方式--&gt;</span><br><span class="line">&lt;!--        &lt;fragment--&gt;</span><br><span class="line">&lt;!--            android:layout_width=&quot;match_parent&quot;--&gt;</span><br><span class="line">&lt;!--            android:layout_height=&quot;match_parent&quot;--&gt;</span><br><span class="line">&lt;!--            android:id=&quot;@+id/fragment&quot;--&gt;</span><br><span class="line">&lt;!--            android:name=&quot;com.thefu.androidstudyproject.MyFragment&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>接下来在MainActivity中添加代码：<br>public class FragmentActivity extends AppCompatActivity {</p>
<pre><code>private Button frag_btn;
private LinearLayout linearLayout;
@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    //静态加载
    setContentView(R.layout.activity_ftagment);
</code></pre>
<p>&#x2F;&#x2F;        frag_btn &#x3D; findViewById(R.id.frg_btn);<br>&#x2F;&#x2F;        frag_btn.setOnClickListener(new View.OnClickListener() {<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;            @Override<br>&#x2F;&#x2F;            public void onClick(View view) {<br>&#x2F;&#x2F;                Toast.makeText(FragmentActivity.this, “您点击了按钮”, Toast.LENGTH_SHORT).show();<br>&#x2F;&#x2F;            }<br>&#x2F;&#x2F;        });<br>        linearLayout &#x3D; findViewById(R.id.layout);</p>
<pre><code>    //动态加载
    MyFragment fragment = new MyFragment();
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction beginTransacction = fragmentManager.beginTransaction();
    beginTransacction.add(R.id.layout, fragment); //把碎片放到布局的layout容器里面
    beginTransacction.addToBackStack(null); //允许用户通过按键返回前一个Fragment状态
    beginTransacction.commit();

&#125;
</code></pre>
<p>}</p>
<p>可将整个过程大致分为三个步骤：<br>第一步，先用getSupportFragmentManager()方法获取一个FragmentManager对象，再通过它的beginTransacction()获取一个FragmentTransaction的实例。</p>
<p>第二步，用beginTransaction.add()方法将MyFragemnt实例添加到main布局里LinearLayout里，终于知道之前铺垫的Id是怎么回事了。一定要注意，add()方法里的第一个参数是容器视图资源Id，而不是layout。容器视图资源Id有两个作用：告知FragmentManager，碎片视图应该出现在活动视图的什么地方；它也是FragmentManager队列中碎片的唯一标识符。而静态加载时碎片的唯一标识符正是在活动布局里&lt; fragment&gt;下的id。</p>
<p>第三步，调用beginTransaction.commit()提交。另外，如果允许用户通过按下返回按键返回到前一个Fragment状态，在调用commit()之前先调用addToBackStack(true)方法。</p>
<p>这里注意到动态加载进来的Fragment里的空间并不能直接在活动中findViewById得到，那么如何实现点击效果呢？</p>
<h3 id="4-Fragment与Activity之间通信"><a href="#4-Fragment与Activity之间通信" class="headerlink" title="4.Fragment与Activity之间通信"></a>4.Fragment与Activity之间通信</h3><p>在活动中可以调用FragmentManager的findFragmentById()方法来得到相应碎片的实例，继而可以调用碎片里的方法，以上面的demo为例，如果想得到静态加载碎片的实例，可在MainActivity添加代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyFragment myFragment = (MyFragment)getFragmentManager(). findFragmentById(R.id.fragment);</span><br></pre></td></tr></table></figure>
<p>如果想得到动态加载碎片的实例，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyFragment myFragment = (MyFragment)fragmentManager(). findFragmentById(R.id.layout);</span><br></pre></td></tr></table></figure>

<p>在碎片中也可以调用getActivity()方法来得到和当前碎片相关联的活动实例，这样调用活动里的方法就变得轻而易举了，比如想在MyFragment得到MainActivity的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity activity=(MainActivity)getActivity();</span><br></pre></td></tr></table></figure>
<p>于是碎片和活动可以很方便的进行通信了，再想一下碎片和碎片之间如何进行通信？先在要给碎片中可以得到与它相关的活动，然后再通过这个活动去获取另一个碎片实例，这样实现了不同碎片之间的通信了。</p>
<p>在实际开发中，如果某一板块每次用到都需要相同的功能，就完全可以在碎片中实现需求，而不必在活动中重复代码，这样可以提高代码的复用性。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式系列——工厂模式</title>
    <url>/2022/12/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>学习技术深度的时候（看一些框架的源码）总感觉只理解了表面，而没有理解里面的思想。<br>这里大家应该都知道我想说什么，就是设计模式。</p>
<span id="more"></span>

<p>今天聊一下工厂模式，工厂模式在我们的电商领域的应用是非常广泛的，写之前我看了自己电脑项目的代码，确实随处可见。<br>工厂模式主要可以分为三大类：<br>简单工厂模式<br>工厂方法模式<br>抽象工厂模式</p>
<p>今天我也主要围绕这三种模式来举例了解一下</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>工厂模式主要是用于对实现逻辑的封装，并且通过对公共的接口提供对象的实例化的服务，在我添加新的类时不需要大动干戈，只要修改一点就好。</p>
<p>举个电商业务是怎么创建商品的：<br><a href="https://imgse.com/i/zXVPc8"><img src="https://s1.ax1x.com/2022/12/21/zXVPc8.jpg" alt="zXVPc8.jpg"></a><br>在这个简单工厂里面，如果要创建活动商品1以及活动商品2，我们要创建商品的时候只要调用简单工厂里面的创建商品方法，根据类型创建出不同的商品然后实例化返回就可以了。</p>
<p>简单工厂几种实现方式：</p>
<h3 id="静态工厂模式"><a href="#静态工厂模式" class="headerlink" title="静态工厂模式"></a>静态工厂模式</h3><p>我们还是以创建商品为例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleFacttory &#123;</span><br><span class="line">	public static Share createProduct(EnumProdutType type) &#123;</span><br><span class="line">		if (EnumProductType.activityone.equals(type)) &#123;</span><br><span class="line">			return new ProductOne();</span><br><span class="line">		&#125; else if (EnumProductType.acctivityTwo.equals(type)) &#123;</span><br><span class="line">			return new ProductTwo();</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	public enum EnumProductType &#123;</span><br><span class="line">		activituOne, activityTwo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式创建看起来其实也没有什么问题，根据类型创建不同的商品，但是有一个问题不知道大家发现没有？</p>
<p>是不是我没增加一种类型还要去createProduct方法上修改if else？这不是违背我们的开闭原则吗？</p>
<p>所以这种方式不好，我们还有接下来的两种：<br>使用反射机制<br>直接注册商品对象，添加一个Type类型方法，根据type类型返回自身相同类型的方法。同样的我们还是以创建商品为例：反射实现<br>同样的我们还是以创建商品为例：反射实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleFactoryReflection &#123;</span><br><span class="line"></span><br><span class="line">    private static final Map&lt;EnumProductType, Class&gt; activityIdMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public  static void addProductKey(EnumProductType EnumProduct, Class product) &#123;</span><br><span class="line">        activityIdMap.put(EnumProduct, product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static activityOne product(EnumProductType type) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class productClass = activityIdMap.get(type);</span><br><span class="line">        return (activityOne) productClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        addProductKey(EnumProductType.activityOne, activityOne.class);</span><br><span class="line">        activityOne product = product(EnumProductType.activityOne);</span><br><span class="line">        System.out.println(product.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Producet&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class activityOne extends Producet &#123;</span><br><span class="line">        private String stock;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;activityOne&#123;&quot; +</span><br><span class="line">                    &quot;stock=&#x27;&quot; + stock + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class activityTwo extends Producet &#123;</span><br><span class="line">        private String stock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum EnumProductType &#123;</span><br><span class="line">        activityOne, activityTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看上面的代码，我发现反射其实也很容易就实现了，但是在一些特定的情况下，并不适用，而且在某些特定的情况下是无法实现的，而且反射机制也会降低程序的运行效果，在对想能要求很高的场景下应该避免这种实现。</p>
<p>这里还有一个问题是使用反射不当是很容易导致线上机器出问题的，因为我们反射创建的对象属性是被SoftReference软引用的，所以当**-XX:SoftRefLRUPolicyMSPerMB**没有设置好的话，会让机器的CPU一直很高。当然它的默认值是1000，也就根据大家的情况而定吧。</p>
<p>剩下的一种其实跟反射实现很像，就是为了避免使用反射，在Map的对象中不是存的要添加的类，而是将要添加的每种类对象实例，这个就不写demo了。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式是对静态工厂模式上的一种改进，我们工厂类直接被抽象化，需要具体特定化的逻辑代码转移到实现抽象方法的子类中，这样我们就不要再去修改工厂类（即：不用再去做什么if else修改）这也是我们当前比较常用的一种方式。<br>还是以我们创建商品为例：<br><a href="https://imgse.com/i/zxHvsP"><img src="https://s1.ax1x.com/2022/12/26/zxHvsP.jpg" alt="zxHvsP.jpg"></a><br>看这张图，其实说白了就是再创建一个工厂，用来创建工厂类对象<br>接下来看代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class FactoryMethod &#123;</span><br><span class="line"></span><br><span class="line">    protected abstract Product createProduct(String name);</span><br><span class="line"></span><br><span class="line">    public Product product(String activity, String name) &#123;</span><br><span class="line">        Product product = createProduct(activity);</span><br><span class="line">        product.setProductName(name);</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Product &#123;</span><br><span class="line">        public String productName;</span><br><span class="line"></span><br><span class="line">        public String getProductName() &#123;</span><br><span class="line">            return productName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setProductName(String productName) &#123;</span><br><span class="line">            this.productName = productName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum EnumProductType &#123;</span><br><span class="line">        activityOne(&quot;one&quot;),</span><br><span class="line">        activityTwo(&quot;two&quot;);</span><br><span class="line"></span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        EnumProductType(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先创建一个抽象工厂方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProductFactory extends FactoryMethod&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Product createProduct(String activityId) &#123;</span><br><span class="line">        if (EnumProductType.activityOne.getName().equals(activityId)) &#123;</span><br><span class="line">            //这里可以处理我们自己的想要的业务逻辑代码</span><br><span class="line">            return new OneProduct();</span><br><span class="line">        &#125; else if (EnumProductType.activityTwo.getName().equals(activityId)) &#123;</span><br><span class="line">            return new TwoProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class OneProduct extends Product &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class TwoProduct extends Product &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FactoryMethod factoryMethod = new ProductFactory();</span><br><span class="line">        Product product = factoryMethod.product(&quot;one&quot;, &quot;one&quot;);</span><br><span class="line">        System.out.println(product.getProductName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再创建一个商品工厂去继承抽象工厂方法。</p>
<p>当还有其他类型的时候我们只需要去继承我们创建的工厂方法就可以了。<br>这个代码大家肯定都能实现出来，但是我们真正需要学习的是前辈们这种工厂模式的思想。把这种思想运用到我们真实的业务场景中，学以致用才能对我们有真正的提升。</p>
<p>举个例子</p>
<p>假设现在需要做一个分享商品图片，我们知道商品的类型有很多，比如无SKU商品，有SKU商品，下单分享，邀请分享…等一下列的场景，那我们怎么去设计这个代码做到更加的易懂，易读，今后扩展性好呢？<br>注：sku和spu是电商里面的名词，spu差不多跟item也就是商品是一个维度，一个商品item有很多sku，比如：iphone是一个商品是item也是spu，白色的iphone 12 64G就是一个具体的sku</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Share &#123;</span><br><span class="line">    //获取分享类型</span><br><span class="line"></span><br><span class="line">    String getShareFunctionType();</span><br><span class="line"></span><br><span class="line">    String mainProcess(String shareName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步我们应该都是定义一个创建分享模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ShareFactory &#123;</span><br><span class="line">    private List&lt;Share&gt; shareFunctionList;</span><br><span class="line"></span><br><span class="line">    //根据分享类型获取对应的分享处理方式</span><br><span class="line">    public Share getShareFunction(String type) &#123;</span><br><span class="line">        for(Share shareFunction : shareFunctionList) &#123;</span><br><span class="line">            if (shareFunction.getShareFunctionType().equals(type)) &#123;</span><br><span class="line">                return shareFunction;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum EnumShareType &#123;</span><br><span class="line">        SUCCESS_ORDER(&quot;successOrder&quot;);</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        EnumShareType(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步我们再创建一个分享工厂根据我们的类型获取我们预先加载在Spring容器中的bean实例<br>public class SuccessOrderShare implements Share {<br>    public String getShareFunctionType() {<br>        return ShareFactory.EnumShareType.SUCCESS_ORDER.getName();<br>    }</p>
<pre><code>public String mainProcess(String shareName) &#123;
    return shareNmae;
&#125;
</code></pre>
<p>}<br><a href="https://imgse.com/i/pSCBWPf"><img src="https://s1.ax1x.com/2023/01/01/pSCBWPf.jpg" alt="pSCBWPf.jpg"></a></p>
<p>最后就是定义我们不同的类型来实现分享图片。<br>其实我们学习设计模式就是这种思想，有了这种思想上面提到的三点又是才能体现出来对我们今后的成长，面对复杂业务设计以及思考能力才能提升。</p>
<p>那么问题来了，什么时候改用工厂方法模式，而非简单工厂模式呢？<br>这里引用设计模式之美里面的一句话：当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。<br>而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>看完工厂方法模式，在理解抽象工厂模式就更加简单，因为它其实就是工厂方法的一个延伸。<br>工厂方法类中只有一个唱响方法，要想实现多种不同的类对象，只能去创建不同的具体工厂方法的子类来实例化，而抽象工厂则是让一个工厂负责创建多个不同类型的对象。<br><a href="https://imgse.com/i/pSCDpL9"><img src="https://s1.ax1x.com/2023/01/01/pSCDpL9.jpg" alt="pSCDpL9.jpg"></a><br>样子可能有点丑，但是能说明问题，其实看上去可以分为以上几个部分组成：<br>抽象工厂类<br>具体工厂类<br>抽象类<br>抽象工厂类我个人可以理解为一个刚出厂的手机，具体抽象工厂则是认为是我们每个人对这个手机壁纸自定义设置，最后抽象类我理解就是手机壁纸。<br>我们每个人可以自定义不同的壁纸：例如动图，静图风景等等。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列——流程引擎</title>
    <url>/2023/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>在电商里面处理复杂的业务逻辑场景有很多，我们还是以创建商品为例子。很多人可能会问创建商品很复杂吗？</p>
<span id="more"></span>

<p>创建商品的流程：<br>参数必填性校验<br>参数数据转换<br>商品基础信息校验<br>商品与商家之间的校验<br>类目信息校验<br>商品交易信息校验（这个看公司业务决定）<br>SKU相关信息校验<br>商品是否需要有特定标签校验（看公司业务决定）<br>商品类型校验（普通，卡片，视频…….）<br>商品风控校验<br>保存商品信息<br>保存SKU信息<br>保存商品详情信息<br>重量模版<br>运费<br>配送区域<br>。。。。。。。<br>这里商品类型里面还涉及到各个业务场景校验，我们就先不谈了。针对这样的情况我们应该怎么去写这个代码呢？我翻看了一下以前大学写的一些代码整体的代码格式大概也就是这个样子<br><a href="https://imgse.com/i/pSCrA7n"><img src="https://s1.ax1x.com/2023/01/01/pSCrA7n.jpg" alt="pSCrA7n.jpg"></a><br>这么写其实也没有什么问题，功能也能实现。但是这么写其实有很多弊端：<br>1.代码可读性不高<br>2.代码扩展性不高<br>3.耦合性太强，有些东西不好公用<br>4.整体创建执行流程事件太长，串行调用下游服务</p>
<p> 看到这样代码我们首先都是吐槽一番，然后还是老老实实去改，有动手能力强的会想着去优化一下。再看看这个流程，其实在创建商品的时候我们很多校验和保存数据是没有依赖且互不影响的，我们完全可以去并行执行。</p>
<p>节省创建商品的流程时间，提高用户体验。（PS：就好比两条告诉一条堵车，一条畅通无阻，选哪条？）<br>所以针对这么并行问题我还是给大家画了一个流程图：<br><a href="https://imgse.com/i/pSCsXJP"><img src="https://s1.ax1x.com/2023/01/01/pSCsXJP.jpg" alt="pSCsXJP.jpg"></a><br>通过这张图我们看到创建一个商品流程，我们调用的下游服务可能是有十几二十几或者更多，假设我们一次RPC调用的平均返回时间是50毫秒，串行执行时间可能就1-2秒了，那么我们并行执行的话也就200到300毫秒了。</p>
<p>所以本着这种思想可能会有人问，为什么我不能异步，不能用消息？创建商品假设用异步消息的话，如果消费失败那用户创建商品成功保存其他信息失败了，那对用户来说不是体验更加不好了</p>
<p>说了这么多开始撸代码：<br><a href="https://imgse.com/i/pSCykiq"><img src="https://s1.ax1x.com/2023/01/01/pSCykiq.jpg" alt="pSCykiq.jpg"></a><br>先创建一个Context上下文，作为我们调用下游服务的返回结果<br><a href="https://imgse.com/i/pSCyAJ0"><img src="https://s1.ax1x.com/2023/01/01/pSCyAJ0.jpg" alt="pSCyAJ0.jpg"></a><br>第二步创建我们的流程节点，这相当于就是保存我们整个流程中需要执行下游服务的节点，以Map作为保存数据，NodeConf节点设置参数，自定义请求服务器超时时间（因为并行我们用的线程池或者通过get设置时间get返回值结果）<br><a href="https://imgse.com/i/pSPnMDJ"><img src="https://s1.ax1x.com/2023/01/02/pSPnMDJ.jpg" alt="pSPnMDJ.jpg"></a><br>第三步引擎类，这个也是我们的核心类。通过我们添加的node节点判断我们哪些流程是需要串行的哪些是需要并行的，通过线程池创建线程放入Feature中，来1达到同步执行的效果</p>
<p>在使用线程池的时候我们需要考虑不要设置的参数过大，开启另外的线程也是会占用机器内存的，一个线程按照1兆来算的话，你开启几百上千个，也会占用很大一部分内存。尽可能的去采用池化的思想，这里就按大家实际场景去做测试了。</p>
<p><a href="https://imgse.com/i/pSPnJC6"><img src="https://s1.ax1x.com/2023/01/02/pSPnJC6.jpg" alt="pSPnJC6.jpg"></a><br>第四步执行call方法，也就是执行我们的node节点</p>
<p><a href="https://imgse.com/i/pSPnY8K"><img src="https://s1.ax1x.com/2023/01/02/pSPnY8K.jpg" alt="pSPnY8K.jpg"></a><br>第五步创建节点接口，这里我们定义一个ResultKey，这个Key也就是跟我流程中的这个节点绑定，在获取数据的时候也就是通过这个key来标识</p>
<p><a href="https://imgse.com/i/pSPnNvD"><img src="https://s1.ax1x.com/2023/01/02/pSPnNvD.jpg" alt="pSPnNvD.jpg"></a><br>第六步因为我们在节点里面存的Class类，所以我们得通过实现ApplicationContextAware类来获取Spring容器中得bean实例</p>
<p><a href="https://imgse.com/i/pSPn68f"><img src="https://s1.ax1x.com/2023/01/02/pSPn68f.jpg" alt="pSPn68f.jpg"></a><br>第七步那就是来创建两个测试node节点</p>
<p><a href="https://imgse.com/i/pSPRVmT"><img src="https://s1.ax1x.com/2023/01/02/pSPRVmT.jpg" alt="pSPRVmT.jpg"></a><br><a href="https://imgse.com/i/pSPRZ0U"><img src="https://s1.ax1x.com/2023/01/02/pSPRZ0U.jpg" alt="pSPRZ0U.jpg"></a><br>最后当然就是我们得测试结果了，这里我们创建两个节点NodeOne和NodeTwo作为模拟真实业务场景得节点，通过一个后面得three作为一个group需要并执行的节点。<br>看完代码最后再给大家来一个总体的流程图吧<br><a href="https://imgse.com/i/pSPRutJ"><img src="https://s1.ax1x.com/2023/01/02/pSPRutJ.jpg" alt="pSPRutJ.jpg"></a><br>看完是不是觉得感觉自己顿悟，以后面对再复杂的流程业务也能拿下了。</p>
<p>思考：<br>其实这里还有很多优化点，每个人遇到的复杂的场景可能也不一样，只能说给大家提供一个思想吧，针对不同的场景大家再去做改造吧</p>
<p>扩展：<br>细心的同学可能都会发现这都是强依赖性，能不能有弱依赖在里面呢？<br>答案：<br>当然可以有弱依赖了，在FlowNode.NodeConf中我们既然可以设置超时时间，我们也可以再添加一个参数来确定是都是弱依赖。在我们的future.get获取结果的时候当出现异常可以catch住，强依赖则终止流程返回错误信息，否则记录错误日志，流程continue</p>
<p>我们流程保存现在是用的静态代码块，可不可以换其他的方式保存节点呢？</p>
<p>答案：这个当然也可以，我们保存在数据库，ACM，Apollo等等都是可以的。这个取决于你们自己的业务和成本问题。因为流程我们一般是不会经常换的，所以我还是建议代码写死就可以了</p>
<p>采用线程池去调用下游服务，会不会造成服务链路追踪失败呢？</p>
<p>答案：这个不能说绝对，但是如果是保存再ThreadLocal中那肯定会失效的，ThreadLocal中的KEY也就是跟当前线程的ID有关，都开启新的线程了，那肯定也就是丢失了</p>
<p>如果采用ThreadLocal在节点中是不是就失效了</p>
<p>答案：第三点已经给出答案了</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列 — 单例模式</title>
    <url>/2022/12/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E2%80%94-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>开篇给大家一个思考题：为什么不用静态方法而用单例模式？</p>
<span id="more"></span>

<p>单例的定义：在当前进程中，通过单例模式创建的类有且只有一个实例。</p>
<p>单例有如下几个特点：<br>1.在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在<br>2.构造器必须是私有的，外部类无法通过调用构造器创建该实例<br>3.没有公开的set方法，外部类无法调用set方法创建该实例<br>4.提供一个公开的get方法获取唯一的这个实例</p>
<p>那单例模式有什么好处呢？<br>1.某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销<br>2.省去了new操作符，降低了系统内存的使用频率，减轻GC压力<br>3.系统中某些类，如Spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统就全乱了<br>4.避免了对资源的重复占用</p>
<p>好了，单例模式的定义也清楚了，好处也了解了，先看一个饿汉式的写法：</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  // 创建一个实例对象</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    /**</span><br><span class="line">     * 私有构造方法，防止被实例化</span><br><span class="line">     */</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    /**</span><br><span class="line">     * 静态get方法</span><br><span class="line">     */</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以叫饿汉式大家可以理解为它饿，他想提前把对象new出来，这样别人哪怕是第一次获取这个类对象的时候直接就存在这个类了，省去了创建类这一步开销。</p>
<p>下面介绍懒汉式</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>线程不安全的模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉式大家可以理解为它懒，别人第一次调用的时候他发现自己的实例是空的，然后去初始化了，再赋值，后面的调用就和饿汉没区别了。</p>
<p>懒汉和饿汉的对比：大家可以发现两者的区别基本上就是第一次创作时候的开销问题，以及线程安全问题（线程不安全模式的懒汉）。<br>那有了这个对比，那他们的场景就好理解了，在很多电商场景，如果这个数据是经常访问的热点数据，那我就可以再系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了。</p>
<p>而懒汉式呢我们可以用在不怎么热的地方，比如那个数据你不确定很长一段时间是不是有人调用，那就用懒汉，如果你使用了饿汉，但是过了几个月还没有人调用，提前加载的类再内存中是由资源浪费的。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>上面的懒汉我是故意没有加锁的，大家肯定都知道懒汉的线程安全问题<br><a href="https://imgse.com/i/z4IcQK"><img src="https://s1.ax1x.com/2022/12/13/z4IcQK.jpg" alt="z4IcQK.jpg"></a><br>在运行过程中可能存在这么一种情况：多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生一种情况，当第一个线程在执行if(instance &#x3D;&#x3D; null)时，此时instance是为null的进入语句。</p>
<p>在还没有执行instance &#x3D; new Singleton()时（此时instance是为null的）第二个线程也进入了if(instance &#x3D;&#x3D; null)这个语句，因为之前进入这个语句的线程中还没有执行instance &#x3D; new Singleton()，所以它会执行instance &#x3D; new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它会实例化Singleton对象。</p>
<p>这样就导致了实例化两个Singleton对象，那怎么解决呢？</p>
<p>简单粗暴，加锁就好了，这是加锁之后的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    /**</span><br><span class="line">     * 私有构造方法，防止被实例化</span><br><span class="line">     */</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    /**</span><br><span class="line">     * 静态get方法</span><br><span class="line">     */</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种典型的时间换空间的写法，不管三七二十一，每次创建实例时先锁起来，在进行判断，严重降低了系统的处理速度。</p>
<p>有没有更好的处理方式呢？<br>有，通过双检锁做两次判断，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        //先检查实例是否存在，如果不存在才进入下面的同步块</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            //同步块，线程安全的创建实例</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                //再次检查实例是否存在，如果不存在才真正的创建实例</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。</p>
<p>但是，这样就没有问题了吗？</p>
<p>看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance &#x3D; new Singleton();语句是分两部执行的。</p>
<p>但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。</p>
<p>这样就可能出错了，我们以A、B两个线程为例：<br>1.A、B线程同时进入了第一个if判断<br>2.A首先进入synchronized块，由于instance为null，所以它执行instance &#x3D; new Singleton();<br>3.由于JVM内部的优化机制，JVM先画了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。<br><a href="https://imgse.com/i/z4oQOO"><img src="https://s1.ax1x.com/2022/12/13/z4oQOO.jpg" alt="z4oQOO.jpg"></a><br>4.B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。<br>5.此时B线程打算使用singleton实例，却发现它并没有被初始化，于是出现了错误。<br>加上volatile修饰Singleton，再做一次优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        //先检查实例是否存在，如果不存在才进入下面的同步块</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            //同步块，线程安全的创建实例</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                //再次检查实例是否存在，如果不存在才真正的创建实例</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过volatile修饰的变量，不会被线程本地缓存，所有线程对该对象的读写都会第一时间同步到主内存，从而保证多个线程间对该对象的准确性</p>
<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><p>防止指令重排序，因为instance &#x3D; new Singleton()不是原子操作<br>保证内存可见</p>
<p>这个是比较完美的写法了，这种方式能够安全的创建唯一的一个实例，又不会对性能有太大的影响。</p>
<p>但是由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，还有更优的写法吗？</p>
<p>通过静态内部类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">  </span><br><span class="line">    /* 私有构造方法，防止被实例化 */  </span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 此处使用一个内部类来维护单例 */  </span><br><span class="line">    private static class SingletonFactory &#123;  </span><br><span class="line">        private static Singleton instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 获取实例 */  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  </span><br><span class="line">    public Object readResolve() &#123;  </span><br><span class="line">        return getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类加载的时候，这个类的加载过程是线程互斥的。</p>
<p>这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。</p>
<p>同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式。</p>
<p>还有更完美的写法吗？通过枚举</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span><br><span class="line">     */</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举来实现单实例控制会更加简洁，而且JVM从根本上提供保障，绝对防止多次实例化，是更简洁，高效，安全的实现单例的方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后大家应该都知道单例模式的写法了，也知道优劣势和使用场景了，那开头的那个问题大家心里有答案了么？</p>
<p>什么？连问题都忘了？问题：为什么不用静态方法而用单例模式？</p>
<p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，面向对象的代码提供一个更好的编程思想。</p>
<p>如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，反之他就应该是非静态的。如果我们确实应该使用非静态的方法，但是在创建类时又确实只需要维护一份实例时，就需要用单例模式了。</p>
<p>我们的电商系统中就有很多类，有很多配置和属性，这些配置和属性是一定存在了，又是公共的，同时需要在整个生命周期中都存在，所以只需要一份就行，这个时候如果需要我再需要的时候new一个，再给他分配值，显然是浪费内存并且再赋值没什么意义。</p>
<p>所以我们用单例模式或静态方法去维持一份这些值有且只有这一份值，但此时这些配置和属性又是通过面向对象的编码方式得到的，我们就应该使用单例模式，或者不是面向对象的，但他本身的属性应该是面对对象的，我们使用静态方法虽然能同样解决问题，但是最好的解决方案也应该是使用单例模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>函数响应式编程——RxJava</title>
    <url>/2023/04/30/%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94RxJava/</url>
    <content><![CDATA[<p>函数响应式编程是一种编程范式。我们常见的编程范式由命令式编程、函数式编程和逻辑式编程。我们常见的面向对象编程是一种命令式编程。命令式编程是面向计算机硬件的抽象，<br>有变量、赋值语句、表达式和控制语句。而函数式编程是面向数学的抽象，将计算描述为一种表达式求职，函数可以在任何地方定义，并且可以对函数进行组合。<br>响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。把函数式编程里的一套思路和响应式编程合起来就是函数响应式编程。<br>在Android开发中使用函数响应式编程的主要有两大框架：一个是RxJava，另一个是Google推出的Agera。</p>
<p>RxJava是ReactiveX的一种Java实现，ReactiveX是Reactive Extensions的缩写，一般简写为Rx。<br>微软的定义是：Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序。开发者可以用Observables表示异步数据流，用<br>LINQ操作符查询一部数据流，用Schedulers参数化一部数据流的并发处理，Rx可以这样定义：Rx &#x3D; Observables+LINQ+Schedulers。</p>
<p>1.为何要用RxJava<br>说到异步操作，我们会想到Android的AsyncTask和Handler。但是随着请求的数量越来越多，代码逻辑将会变得越来越复杂而RxJava却仍旧能保持清晰的逻辑。<br>RxJava的原理就是创建一个Observable对象来干活，然后使用各种操作符建立起来的链式操作，就如同流水线一样，把你想要处理的数据一步一步地加工成你<br>想要的成品，然后发射给Subscriber处理</p>
<p>2.RxJava与观察者模式<br>RxJava的异步操作是通过扩展的观察者模式来实现的。RxJava有4个角色Observable、Observer、Subscriber和Suject，这4个角色后面会具体讲解。<br>Observable和Observer 通过subscribe方法实现订阅关系，Observable就可以在需要的时候通知Observer</p>
<p>3.RxJava的基本实现<br>1）创建Observer(观察者)<br>它决定事件触发的时候将有怎样的行为，其中onCompleted、onError和onNext是必须要实现的方法。<br>2）创建Observable(被观察者)<br>它决定什么时候触发事件以及触发怎样的事件。RxJava使用create方法，just方法，或者from方来创建一个Observable<br>2）Subscribe(订阅)<br>订阅只需要一行代码就可以了<br>observable.subscribe(subscriber)</p>
<p>3.Subject<br>subject既可以是一个Observer，也可以是一个Observerable,它是连接Observer和Observerable的桥梁，因此，Subject可以被理解为Subject&#x3D;Observable+Observer。<br>RxJava提供了以下4种Subject:</p>
<ol>
<li>PublishSubject<br>publishsubject只会把在订阅发生的事件点之后来自原始Observable的数据发生给观察者。如果要确保来自原始Observable的所有数据都被分发，<br>则可以当所有观察者都已经订阅时才开始发射数据，或者改用ReplaySubject。<br>2）BehaviorSubject<br>当Observer订阅BehaviorSubject时，它开始发射原始Observable最近发射的数据<br>3）ReplaySubject<br>不管Observer何时订阅ReplaySubject，ReplaySubject均会发射所有来自原始Observable的数据给Observer。如果使用ReplaySubject作为Observer，注意不要在多个线程中调用onNext、onComplete和onError方法。这可能会导致顺序错乱，并且违反了Observer规则。<br>4）AsyncSubject<br>当Observable完成时，AsyncSubject只会发射来自原始Observable的最后一个数据</li>
</ol>
<p>4.RxJava操作符<br>RxJava操作符的类型分为创建操作符、变换操作符、过滤操作符、组合操作符、错误处理操作符、辅助操作符、条件和布尔操作符、算术和聚合操作符及连接操作符等，<br>而这些操作符类型下又有很多操作符，每个操作符可能还有很多变体。</p>
<p>创建操作符：create,just,from,defer,range,interval,start,repeat,timer<br>变换操作符：map,flatMap,concatMap,switchMap等<br>过滤操作符：filter,elementAt,distince,skip,take<br>组合操作符：startWith,merge,concat,zip</p>
]]></content>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>View的事件分发机制</title>
    <url>/2023/04/30/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>在讲到View的事件分发机制之前要首先了解一下Activity的组成，然后从源码的角度来分析View的事件分发机制。</p>
<h2 id="一、源码解析Activity的构成"><a href="#一、源码解析Activity的构成" class="headerlink" title="一、源码解析Activity的构成"></a>一、源码解析Activity的构成</h2><p>点击事件用MotionEvent来表示，当一个点击事件产生后，事件最先传递给Activity，所以我们首先了解一下Activity的构成。当我们写Activity时，会调用setContentView()<br>方法来加载布局。现在来看看setContentView()方法是怎么实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">	getWindow().setContentView(layoutResID);</span><br><span class="line">	initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里调用了getWindow().setContentView(layoutResID)，getWindow()指的PhoneWindow，在PhoneWindow的setContentView()方法里，先是有installDecor()方法<br>该方法里面调用了generateDecor()方法，在这里创建了一个DecorView，这个DecorView就是Activity的根View.<br>在PhoneWindow中的installDecor()方法中，还有一个generateLayout(mDecor)方法，其主要内容就是根据不同的情况加载不同的布局给layoutResource。</p>
<p>一个Acticity包含一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根，而这个DecorView又将屏幕<br>划分为两个区域，一个是TitleView，另一个是ContentView，而我们平常做应用所写的布局正是展示在ContentView中的。</p>
<h2 id="二、源码解析View的事件分发机制"><a href="#二、源码解析View的事件分发机制" class="headerlink" title="二、源码解析View的事件分发机制"></a>二、源码解析View的事件分发机制</h2><p>当我们点击屏幕时，就产生了点击事件，这个事件被封装成一个类：MotionEvent。而当这个MotionEvent产生后，那么系统就会将这个MotionEvent传递给View的层级，<br>MotionEvent在View中的层级传递就是点击事件分发。事件分发的三个重要方法：<br>dispatchTouchEvent(MotionEvent ev)——用来进行事件的分发。<br>onInterceptTouchEvent(MotionEvent ev)——用来进行事件的拦截，在dispatchTouchEvent()方法中调用，需要注意的是View没有提供该方法。<br>onTouchEvent(MotionEvent ev)——用来处理点击事件，在dispatchTouchEvent()方法中调用。</p>
<h3 id="1-View的事件分发机制"><a href="#1-View的事件分发机制" class="headerlink" title="1.View的事件分发机制"></a>1.View的事件分发机制</h3><p>当点击事件产生后，事件首先会传递给当前的Activity，这会调用Activity的dispatchTouchEvent()方法，当然具体的事件处理工作都是交由Activity中的PhoneWindow来完成的，然后PhoneWindow再把事件处理工作交给DecorView，之后再由<br>DecorView将事件处理工作交给根ViewGroup。所以，我们从ViewGroup的dispatchTouchEvent()方法开始分析，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchTouchEvent (MotionEvent ev) &#123;</span><br><span class="line">	...</span><br><span class="line">	if (actionMasked == MotionEvent.ACTION_ DOWN) &#123;</span><br><span class="line">		cancelAndClearTouchTargets (ev);</span><br><span class="line">		resetTouchState () ;</span><br><span class="line">	&#125;</span><br><span class="line">	if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">|		|| mFirstTouchTarget != null) (//1</span><br><span class="line">		final boolean disallowIntercept = (GroupFlags &amp; FLAG_DISALLOW_</span><br><span class="line">		INTERCEPT) != 0;//2 if (!disallowIntercept) I</span><br><span class="line">		intercepted = onInterceptTouchEvent (ev);</span><br><span class="line">		ev. setAction (action);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		intercepted = false;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		intercepted = true;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先判断事件是否Down事件，如果是，则进行初始化，resetTouchState方法中会把mFirstTouchTarget的值置为null<br>这里为啥要初始化呢？<br>因为一个完整的事件序列是从DOWN开始，以UP结束的。所以如果是DOWN事件，那么说明这是一个新的事件序列，故而需要初始化之前的状态。<br>当ViewGroup要拦截事件的时候，那么后续的事件序列都将交给它处理，而不用再调用onInterceptTouchEvent()方法了，所以，onInterceptTouchEvent()<br>方法并不是每次事件都会调用的。<br>onInterceptTouchEvent()方法默认返回false，不进行拦截。如果想要让ViewGroup拦截事件，那么应该在自定义的ViewGroup中重写这个方法。<br>在dispatchTouchEvent()方法剩余的部分：<br>首先遍历ViewGroup的子元素，判断子元素是否能够接受到点击事件，如果子元素能够接收到点击事件，则交由子元素来处理。需要注意这个for循环<br>是倒序遍历的，即从最上层的子View开始往内层遍历。。同时它也会判断触摸点位置是否在子view的范围内或者子View是否正在播放动画，如果均不符合则<br>执行continue语句，表示这个子View不符合条件，开始遍历下一个子View。<br>如果有子View，则调用子View的dispatchTouchEvent(event)方法，如果ViewGroup没有子View，则调用super.dispatchTouchEvent(event)方法。viewgroup没有子View<br>则调用super.dispatchTouchEvent(event)方法。ViewGroup是集成View的。在View的dispatchTouchEvent(event)中，如果OnTouchListener不为null并且onTouch方法返回true，<br>则表示事件被消费，就不会执行onTouchEvent(event)，否则就会执行，可以看出OnTouchListener中的onTouch方法优先级要高于onTouchEvent(event)。<br>在onTouchEvent()方法中，只要View的Clickable和Long_clickable有一个为true，那么onTouchEvent()方法就会返回true消耗这个事件。前面两个变量分别代表<br>view可以被点击和长按点击，可以通过View的setClickable和setLongClickable方法来设置，也可以通过View的setOnclickListener和setOnLongClickListener来设置，它们<br>会自动将View设置为Lickable和Long_clickable<br>接着在Action_UP事件会调用performClick()方法，如果View设置了OnClickListener，那么它的onClick()方法就会被执行。</p>
<h3 id="点击事件分发的传递规则"><a href="#点击事件分发的传递规则" class="headerlink" title="点击事件分发的传递规则"></a>点击事件分发的传递规则</h3><p>当点击事件产生后会由Activity来处理，传递给PhoneWindow，再传递给DecorView，最后传递给顶层的ViewGroup，一般在事件传递中只考虑ViewGroup的<br>onInterceptTouchEvent方法，因为一般情况下我们不会重写dispatchTouchEvent()方法，对呀根ViewGroup，点击事件首先传递给它dispatchTouchEvent()方法，如果该ViewGroup的onInterceptTouchEvent()方法返回true，则表示它<br>要拦截这个事件，这个事件就会交给它的onTouchEvent()方法处理，如果onInterceptTouchEvent（）方法返回false，则表示它不拦截这个事件，则这个事件会交给它的子元素的dispatchTouchEvent（）来处理，如此反复下去。如果传递给底层的View，<br>View是没有子View的，就会调用View的dispatchTouchEvent（）方法，一般情况下最终会调用View的onTouchEvent（）方法。</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
